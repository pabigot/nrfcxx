<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nrfcxx: nrfcxx::systemState Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">nrfcxx
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
   <div id="projectbrief">C++-17 Framework for Nordic nRF5 Devices</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenrfcxx.html">nrfcxx</a></li><li class="navelem"><a class="el" href="classnrfcxx_1_1systemState.html">systemState</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">nrfcxx::systemState Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A class supporting watchdog configuration and cross-reset retention of state.  
 <a href="classnrfcxx_1_1systemState.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="core_8hpp_source.html">nrfcxx/core.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1systemState_1_1scoped__sleeper.html">scoped_sleeper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAII instance that configures the operational mode to enter <a class="el" href="classnrfcxx_1_1systemState.html#ac894d0b0cb64545e01bd2567cb4cc557aa16fc7345f86746bc16dd3c05e63a02a" title="Operational mode flag indicating that CPU is turned off.">OM_SLEEP</a> when constructed, and to leave <a class="el" href="classnrfcxx_1_1systemState.html#ac894d0b0cb64545e01bd2567cb4cc557aa16fc7345f86746bc16dd3c05e63a02a" title="Operational mode flag indicating that CPU is turned off.">OM_SLEEP</a> when destructed.  <a href="classnrfcxx_1_1systemState_1_1scoped__sleeper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrfcxx_1_1systemState_1_1state__type.html">state_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The raw data supporting cross-reset state transfer.  <a href="structnrfcxx_1_1systemState_1_1state__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac894d0b0cb64545e01bd2567cb4cc557"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1systemState.html#ac894d0b0cb64545e01bd2567cb4cc557">om_enum</a> : om_type { <a class="el" href="classnrfcxx_1_1systemState.html#ac894d0b0cb64545e01bd2567cb4cc557aa16fc7345f86746bc16dd3c05e63a02a">OM_SLEEP</a> = 0x01, 
<a class="el" href="classnrfcxx_1_1systemState.html#ac894d0b0cb64545e01bd2567cb4cc557a7b19f58c60fda7e7f8500ac119ce67e1">OM_HFCLK</a> = 0x02, 
<a class="el" href="classnrfcxx_1_1systemState.html#ac894d0b0cb64545e01bd2567cb4cc557a346b36045c4548ae296f493288970e08">OM_RADIO</a> = 0x04, 
<a class="el" href="classnrfcxx_1_1systemState.html#ac894d0b0cb64545e01bd2567cb4cc557acce8e7c9790af9ec94f99b7fc37948c8">NUM_OPERATIONAL_MODES</a> = (OM_RADIO &lt;&lt; 1)
 }</td></tr>
<tr class="memdesc:ac894d0b0cb64545e01bd2567cb4cc557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bits used to build up an operational mode.  <a href="classnrfcxx_1_1systemState.html#ac894d0b0cb64545e01bd2567cb4cc557">More...</a><br /></td></tr>
<tr class="separator:ac894d0b0cb64545e01bd2567cb4cc557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71bdf7674d318debd2f79aa7783ba336"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1systemState.html#a71bdf7674d318debd2f79aa7783ba336">app_handler_type</a> = void(*)(const <a class="el" href="structnrfcxx_1_1systemState_1_1state__type.html">state_type</a> &amp;ss, bool is_reset, bool was_retained)</td></tr>
<tr class="memdesc:a71bdf7674d318debd2f79aa7783ba336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a function allowing application state maintenance.  <a href="#a71bdf7674d318debd2f79aa7783ba336">More...</a><br /></td></tr>
<tr class="separator:a71bdf7674d318debd2f79aa7783ba336"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1f857a749c014b352e2cfee0c839b2f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1systemState.html#a1f857a749c014b352e2cfee0c839b2f4">systemState</a> (<a class="el" href="structnrfcxx_1_1systemState_1_1state__type.html">state_type</a> &amp;<a class="el" href="classnrfcxx_1_1systemState.html#a69a61e5bd8626d974c11ec9719349ec1">state</a>, uint32_t magic, <a class="el" href="classnrfcxx_1_1systemState.html#a71bdf7674d318debd2f79aa7783ba336">app_handler_type</a> app_handler=nullptr)</td></tr>
<tr class="memdesc:a1f857a749c014b352e2cfee0c839b2f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up a wrapper around a cross-reset state object.  <a href="#a1f857a749c014b352e2cfee0c839b2f4">More...</a><br /></td></tr>
<tr class="separator:a1f857a749c014b352e2cfee0c839b2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a61e5bd8626d974c11ec9719349ec1"><td class="memItemLeft" align="right" valign="top"><a id="a69a61e5bd8626d974c11ec9719349ec1"></a>
const <a class="el" href="structnrfcxx_1_1systemState_1_1state__type.html">state_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1systemState.html#a69a61e5bd8626d974c11ec9719349ec1">state</a> () const</td></tr>
<tr class="memdesc:a69a61e5bd8626d974c11ec9719349ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a read-only instance of the state referenced by this object. <br /></td></tr>
<tr class="separator:a69a61e5bd8626d974c11ec9719349ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f8eaa2ba56e331f1f8cb1fb39c7484"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1systemState.html#a42f8eaa2ba56e331f1f8cb1fb39c7484">watchdogInit</a> (unsigned int delay_32KiHz, unsigned int channel_mask=1, bool run_in_sleep=true, bool run_in_debug=false) const</td></tr>
<tr class="memdesc:a42f8eaa2ba56e331f1f8cb1fb39c7484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the watchdog infrastructure.  <a href="#a42f8eaa2ba56e331f1f8cb1fb39c7484">More...</a><br /></td></tr>
<tr class="separator:a42f8eaa2ba56e331f1f8cb1fb39c7484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4ca3525c06e849e0ef0cadef28015f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1systemState.html#a0f4ca3525c06e849e0ef0cadef28015f">watchdogActive</a> () const</td></tr>
<tr class="memdesc:a0f4ca3525c06e849e0ef0cadef28015f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the watchdog infrastructure is active.  <a href="#a0f4ca3525c06e849e0ef0cadef28015f">More...</a><br /></td></tr>
<tr class="separator:a0f4ca3525c06e849e0ef0cadef28015f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30cba0eff0c252c4ace6c794a9566c0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1systemState.html#a30cba0eff0c252c4ace6c794a9566c0b">watchdogFeed</a> (unsigned int channel) const</td></tr>
<tr class="memdesc:a30cba0eff0c252c4ace6c794a9566c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reload a specific channel in the watchdog.  <a href="#a30cba0eff0c252c4ace6c794a9566c0b">More...</a><br /></td></tr>
<tr class="separator:a30cba0eff0c252c4ace6c794a9566c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6c301a3d4fb11cf2da6053d9073428"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1systemState.html#a9e6c301a3d4fb11cf2da6053d9073428">watchdogFeedMulti</a> (unsigned int channel_mask) const</td></tr>
<tr class="memdesc:a9e6c301a3d4fb11cf2da6053d9073428"><td class="mdescLeft">&#160;</td><td class="mdescRight">As with <a class="el" href="classnrfcxx_1_1systemState.html#a30cba0eff0c252c4ace6c794a9566c0b" title="Reload a specific channel in the watchdog.">watchdogFeed()</a> but feeds multiple channels.  <a href="#a9e6c301a3d4fb11cf2da6053d9073428">More...</a><br /></td></tr>
<tr class="separator:a9e6c301a3d4fb11cf2da6053d9073428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c217b7d69b0ea1d361e5c3e3137c56"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1systemState.html#a16c217b7d69b0ea1d361e5c3e3137c56">watchdogCheckExtended</a> ()</td></tr>
<tr class="memdesc:a16c217b7d69b0ea1d361e5c3e3137c56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the extended watchdog channels are current.  <a href="#a16c217b7d69b0ea1d361e5c3e3137c56">More...</a><br /></td></tr>
<tr class="separator:a16c217b7d69b0ea1d361e5c3e3137c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d89b282576ca87d1b3daf2a76c8be6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1systemState.html#aa1d89b282576ca87d1b3daf2a76c8be6">reset</a> (unsigned int code, bool bypass_watchdog=false)</td></tr>
<tr class="memdesc:aa1d89b282576ca87d1b3daf2a76c8be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record some information and reset the system.  <a href="#aa1d89b282576ca87d1b3daf2a76c8be6">More...</a><br /></td></tr>
<tr class="separator:aa1d89b282576ca87d1b3daf2a76c8be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c97aa271471657c67fc02f821267092"><td class="memItemLeft" align="right" valign="top"><a id="a8c97aa271471657c67fc02f821267092"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1systemState.html#a8c97aa271471657c67fc02f821267092">stack_reserved</a> () const</td></tr>
<tr class="memdesc:a8c97aa271471657c67fc02f821267092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of the reserved stack region. <br /></td></tr>
<tr class="separator:a8c97aa271471657c67fc02f821267092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e0197f6e31c97fd74e790aa8aa3421"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1systemState.html#a48e0197f6e31c97fd74e790aa8aa3421">stack_used</a> () const</td></tr>
<tr class="memdesc:a48e0197f6e31c97fd74e790aa8aa3421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of stack region that has been used since startup.  <a href="#a48e0197f6e31c97fd74e790aa8aa3421">More...</a><br /></td></tr>
<tr class="separator:a48e0197f6e31c97fd74e790aa8aa3421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918967addbb22f328fdbf09bcb030b19"><td class="memItemLeft" align="right" valign="top"><a id="a918967addbb22f328fdbf09bcb030b19"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1systemState.html#a918967addbb22f328fdbf09bcb030b19">heap_reserved</a> () const</td></tr>
<tr class="memdesc:a918967addbb22f328fdbf09bcb030b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of the reserved heap region. <br /></td></tr>
<tr class="separator:a918967addbb22f328fdbf09bcb030b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0847917050a38c7070711bbaa52379"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1systemState.html#a5f0847917050a38c7070711bbaa52379">heap_used</a> () const</td></tr>
<tr class="memdesc:a5f0847917050a38c7070711bbaa52379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current total heap allocation.  <a href="#a5f0847917050a38c7070711bbaa52379">More...</a><br /></td></tr>
<tr class="separator:a5f0847917050a38c7070711bbaa52379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45135f97a3d2f9f98f49f6e70b25372"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1systemState.html#ad45135f97a3d2f9f98f49f6e70b25372">operationalModeBreakdown</a> (uint64_t &amp;sleep_utt, uint64_t &amp;radio_utt) const</td></tr>
<tr class="memdesc:ad45135f97a3d2f9f98f49f6e70b25372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide information on the total time spent in various operations states since reset.  <a href="#ad45135f97a3d2f9f98f49f6e70b25372">More...</a><br /></td></tr>
<tr class="separator:ad45135f97a3d2f9f98f49f6e70b25372"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a3d1956a471409a35f2216b7d0836ff40"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1systemState.html#a3d1956a471409a35f2216b7d0836ff40">updateOperationalMode</a> (unsigned int om_clear=0, unsigned int om_set=0)</td></tr>
<tr class="memdesc:a3d1956a471409a35f2216b7d0836ff40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the operational mode.  <a href="#a3d1956a471409a35f2216b7d0836ff40">More...</a><br /></td></tr>
<tr class="separator:a3d1956a471409a35f2216b7d0836ff40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0bd491fa43dcd47b6a480ab87d1d09a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classnrfcxx_1_1systemState_1_1scoped__sleeper.html">scoped_sleeper</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1systemState.html#aa0bd491fa43dcd47b6a480ab87d1d09a">make_scoped_sleeper</a> () noexcept</td></tr>
<tr class="memdesc:aa0bd491fa43dcd47b6a480ab87d1d09a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an RAII object to <a class="el" href="classnrfcxx_1_1systemState_1_1scoped__sleeper.html">track sleep periods</a>.  <a href="#aa0bd491fa43dcd47b6a480ab87d1d09a">More...</a><br /></td></tr>
<tr class="separator:aa0bd491fa43dcd47b6a480ab87d1d09a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c61b6e89968e338c1c12d6979af59c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1systemState.html#a76c61b6e89968e338c1c12d6979af59c">WFE</a> ()</td></tr>
<tr class="memdesc:a76c61b6e89968e338c1c12d6979af59c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issue a <code>__WFE</code> instruction that records time spent sleeping.  <a href="#a76c61b6e89968e338c1c12d6979af59c">More...</a><br /></td></tr>
<tr class="separator:a76c61b6e89968e338c1c12d6979af59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9a55145d4f906917878dff2df6ea97"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1systemState.html#a5b9a55145d4f906917878dff2df6ea97">sd_fault_handler</a> (uint32_t id, uint32_t pc, uint32_t info)</td></tr>
<tr class="memdesc:a5b9a55145d4f906917878dff2df6ea97"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function suitable for use as the <code>fault_handler</code> argument to <code>sd_softdevice_enable()</code>.  <a href="#a5b9a55145d4f906917878dff2df6ea97">More...</a><br /></td></tr>
<tr class="separator:a5b9a55145d4f906917878dff2df6ea97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab843b93b6888a1e218cd03ebd0b1bc88"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1systemState.html#ab843b93b6888a1e218cd03ebd0b1bc88">current_pc</a> ()</td></tr>
<tr class="memdesc:ab843b93b6888a1e218cd03ebd0b1bc88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the address of the instruction after the call.  <a href="#ab843b93b6888a1e218cd03ebd0b1bc88">More...</a><br /></td></tr>
<tr class="separator:ab843b93b6888a1e218cd03ebd0b1bc88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce51653d723f3a75c71896804e3f506"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1systemState.html#a5ce51653d723f3a75c71896804e3f506">total_now</a> ()</td></tr>
<tr class="memdesc:a5ce51653d723f3a75c71896804e3f506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the aggregate time since the retained state was reset.  <a href="#a5ce51653d723f3a75c71896804e3f506">More...</a><br /></td></tr>
<tr class="separator:a5ce51653d723f3a75c71896804e3f506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b631cb9db5b432d8ccaf825ddfc7973"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1systemState.html#a5b631cb9db5b432d8ccaf825ddfc7973">wfe_count</a> ()</td></tr>
<tr class="memdesc:a5b631cb9db5b432d8ccaf825ddfc7973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of times <a class="el" href="classnrfcxx_1_1systemState.html#a76c61b6e89968e338c1c12d6979af59c" title="Issue a __WFE instruction that records time spent sleeping.">WFE()</a> has returned.  <a href="#a5b631cb9db5b432d8ccaf825ddfc7973">More...</a><br /></td></tr>
<tr class="separator:a5b631cb9db5b432d8ccaf825ddfc7973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8b76acd0cf4814181f84fb29da9032"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1systemState.html#a5e8b76acd0cf4814181f84fb29da9032">systemOff</a> (unsigned int preserve, int button_psel=-1)</td></tr>
<tr class="memdesc:a5e8b76acd0cf4814181f84fb29da9032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enter system off mode.  <a href="#a5e8b76acd0cf4814181f84fb29da9032">More...</a><br /></td></tr>
<tr class="separator:a5e8b76acd0cf4814181f84fb29da9032"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ae9326da1133f6a2b425fb1078a5bd07f"><td class="memItemLeft" align="right" valign="top"><a id="ae9326da1133f6a2b425fb1078a5bd07f"></a>
static const char *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1systemState.html#ae9326da1133f6a2b425fb1078a5bd07f">operationalModeText</a> [<a class="el" href="classnrfcxx_1_1systemState.html#ac894d0b0cb64545e01bd2567cb4cc557acce8e7c9790af9ec94f99b7fc37948c8">NUM_OPERATIONAL_MODES</a>]</td></tr>
<tr class="memdesc:ae9326da1133f6a2b425fb1078a5bd07f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Text representations of each operational mode. <br /></td></tr>
<tr class="separator:ae9326da1133f6a2b425fb1078a5bd07f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b798e68f1cb606653f20dbd84ef50bd"><td class="memItemLeft" align="right" valign="top"><a id="a6b798e68f1cb606653f20dbd84ef50bd"></a>
static constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1systemState.html#a6b798e68f1cb606653f20dbd84ef50bd">WATCHDOG_Hz</a> = 32768U</td></tr>
<tr class="memdesc:a6b798e68f1cb606653f20dbd84ef50bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frequency at which the watchdog clock runs. <br /></td></tr>
<tr class="separator:a6b798e68f1cb606653f20dbd84ef50bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab557c38ce89f2359e69e0d21dd9e94af"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1systemState.html#ab557c38ce89f2359e69e0d21dd9e94af">WATCHDOG_MASK_EXTENDED</a> = (1U &lt;&lt; 8)</td></tr>
<tr class="memdesc:ab557c38ce89f2359e69e0d21dd9e94af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pseudo-channel used to support extended watchdog channels.  <a href="#ab557c38ce89f2359e69e0d21dd9e94af">More...</a><br /></td></tr>
<tr class="separator:ab557c38ce89f2359e69e0d21dd9e94af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:abc9f2db2d5d3b6ee0bdd147866f0df35"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structnrfcxx_1_1systemState_1_1state__type.html">state_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1systemState.html#abc9f2db2d5d3b6ee0bdd147866f0df35">statep_</a></td></tr>
<tr class="memdesc:abc9f2db2d5d3b6ee0bdd147866f0df35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the #state_ field of the first <a class="el" href="classnrfcxx_1_1systemState.html#a1f857a749c014b352e2cfee0c839b2f4" title="Set up a wrapper around a cross-reset state object.">systemState</a> instance to be constructed.  <a href="#abc9f2db2d5d3b6ee0bdd147866f0df35">More...</a><br /></td></tr>
<tr class="separator:abc9f2db2d5d3b6ee0bdd147866f0df35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a35a23c67b414b0bd59c6523ca537b"><td class="memItemLeft" align="right" valign="top"><a id="ac2a35a23c67b414b0bd59c6523ca537b"></a>
static <a class="el" href="classnrfcxx_1_1systemState.html#a71bdf7674d318debd2f79aa7783ba336">app_handler_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1systemState.html#ac2a35a23c67b414b0bd59c6523ca537b">app_handler_</a></td></tr>
<tr class="memdesc:ac2a35a23c67b414b0bd59c6523ca537b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the application state handler for the first <a class="el" href="classnrfcxx_1_1systemState.html#a1f857a749c014b352e2cfee0c839b2f4" title="Set up a wrapper around a cross-reset state object.">systemState</a> instance to be constructed. <br /></td></tr>
<tr class="separator:ac2a35a23c67b414b0bd59c6523ca537b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class supporting watchdog configuration and cross-reset retention of state. </p>
<p>Applications may encounter situations where they can no longer function and need to restart. These situations may be detectable by program code and <a class="el" href="classnrfcxx_1_1systemState.html#aa1d89b282576ca87d1b3daf2a76c8be6">initiated intentionally</a>; result from a <a class="el" href="classnrfcxx_1_1systemState.html#a42f8eaa2ba56e331f1f8cb1fb39c7484">watchdog reset</a> detecting failure to execute some critical operation in a timely manner; or when an unrecoverable system failure causes a <a class="el" href="namespacenrfcxx.html#a48a72359e3e4d7aaee4b9ea0d6c6c015" title="Record a critical system failure and reset the system.">failsafe</a> restart.</p>
<p>Information about the reset is available from the <code>POWER</code> module, but for completeness must be accompanied by information persisted from the session that reset. This class supports that state transfer.</p>
<p>Example: </p><pre class="fragment">static __attribute__((__section__(".noinit.systemState")))
  nrfcxx::systemState::state_type state;
nrfcxx::systemState cs{state}; // constructor invoked before main()
int main ()
{
  if (nrfcxx::systemState::state_type::RESET_REAS_FAILSAFE &amp; cs.state().reset_reas) {
    // bring system up in fail-safe mode
  }
</pre> </div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a71bdf7674d318debd2f79aa7783ba336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71bdf7674d318debd2f79aa7783ba336">&#9670;&nbsp;</a></span>app_handler_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnrfcxx_1_1systemState.html#a71bdf7674d318debd2f79aa7783ba336">nrfcxx::systemState::app_handler_type</a> =  void (*) (const <a class="el" href="structnrfcxx_1_1systemState_1_1state__type.html">state_type</a>&amp; ss, bool is_reset, bool was_retained)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of a function allowing application state maintenance. </p>
<p>This function is invoked twice:</p><ul>
<li>As the last step of the constructor, to allow application-specific retained state to be updated based on history from the previous invocation;</li>
<li>As the last step before initiating or waiting out a controlled reset.</li>
</ul>
<p>Implementations should reference internally-held or global retained application state.</p>
<p>A template for filling in state is: </p><pre class="fragment">if (is_reset) {
  // Shutting down.  Save anything that has to be saved
  // that isn't maintained in the structure supported by this
  // function.  If anything is done here, the condition on
  // retained should include the test for RESET_REAS_CONTROLLED.
} else if (retained
           &amp;&amp; (systemState::state_type::RESET_REAS_CONTROLLED &amp; ss.reset_reas)) {
  // Starting up and previous shutdown was controlled. Update
  // from retained state.
} else {
  // Starting up, everything was lost.
}
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sp</td><td>pointer to the initialized system state</td></tr>
    <tr><td class="paramname">is_reset</td><td><code>false</code> on the invocation from the constructor, <code>true</code> on the invocation during a controlled reset.</td></tr>
    <tr><td class="paramname">was_retained</td><td>valid only when <code>is_reset</code> is <code>false</code>, this indicates whether the constructor found a valid state object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ac894d0b0cb64545e01bd2567cb4cc557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac894d0b0cb64545e01bd2567cb4cc557">&#9670;&nbsp;</a></span>om_enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classnrfcxx_1_1systemState.html#ac894d0b0cb64545e01bd2567cb4cc557">nrfcxx::systemState::om_enum</a> : om_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bits used to build up an operational mode. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac894d0b0cb64545e01bd2567cb4cc557aa16fc7345f86746bc16dd3c05e63a02a"></a>OM_SLEEP&#160;</td><td class="fielddoc"><p>Operational mode flag indicating that CPU is turned off. </p>
<p>In <a class="el" href="classnrfcxx_1_1systemState.html#ae9326da1133f6a2b425fb1078a5bd07f" title="Text representations of each operational mode.">operationalModeText</a> this flag is represented in the first character, which is <code>A</code> for active (cleared) and <code>S</code> for sleeping (set). Use <a class="el" href="classnrfcxx_1_1systemState.html#a76c61b6e89968e338c1c12d6979af59c" title="Issue a __WFE instruction that records time spent sleeping.">WFE()</a> to automatically update this part of the mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac894d0b0cb64545e01bd2567cb4cc557a7b19f58c60fda7e7f8500ac119ce67e1"></a>OM_HFCLK&#160;</td><td class="fielddoc"><p>Operational mode flag indicating that high-frequency clock is running. </p>
<p>In <a class="el" href="classnrfcxx_1_1systemState.html#ae9326da1133f6a2b425fb1078a5bd07f" title="Text representations of each operational mode.">operationalModeText</a> this flag is represented in the second character, which is <code>-</code> for disabled (cleared) and <code>H</code> for enabled (set). Control of this flag is managed by <a class="el" href="namespacenrfcxx_1_1clock.html" title="Functions and classes related to clocks and time.">nrfcxx::clock</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Although <a class="el" href="namespacenrfcxx_1_1clock.html" title="Functions and classes related to clocks and time.">nrfcxx::clock</a> will set and clear this flag, when soft devices are used they are responsible for managing HFCLK and this flag will generally remain off even when the clock is enabled. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ac894d0b0cb64545e01bd2567cb4cc557a346b36045c4548ae296f493288970e08"></a>OM_RADIO&#160;</td><td class="fielddoc"><p>Operational mode flag indicating that 2.4 GHz radio is running. </p>
<p>In <a class="el" href="classnrfcxx_1_1systemState.html#ae9326da1133f6a2b425fb1078a5bd07f" title="Text representations of each operational mode.">operationalModeText</a> this flag is represented in the third character, which is <code>-</code> for disabled (cleared) and <code>R</code> for enabled (set). Control of this flag is the responsibility of the application's use of <code>RADIO_IRQHandler</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac894d0b0cb64545e01bd2567cb4cc557acce8e7c9790af9ec94f99b7fc37948c8"></a>NUM_OPERATIONAL_MODES&#160;</td><td class="fielddoc"><p>The number of distinct operational modes supported. </p>
<dl class="section note"><dt>Note</dt><dd>Code depends on this being a power of two. </dd></dl>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1f857a749c014b352e2cfee0c839b2f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f857a749c014b352e2cfee0c839b2f4">&#9670;&nbsp;</a></span>systemState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nrfcxx::systemState::systemState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfcxx_1_1systemState_1_1state__type.html">state_type</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>magic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnrfcxx_1_1systemState.html#a71bdf7674d318debd2f79aa7783ba336">app_handler_type</a>&#160;</td>
          <td class="paramname"><em>app_handler</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set up a wrapper around a cross-reset state object. </p>
<p>This verifies that the retained state is compatible with <code>magic</code>; if not it is cleared. Information available from the reset is copied into the state object.</p>
<dl class="section warning"><dt>Warning</dt><dd>Invoking this will clear <code>NRF_POWER-&gt;RESETREAS</code>. The pre-clear content can be reconstructed from <a class="el" href="structnrfcxx_1_1systemState_1_1state__type.html#a0026b2d4a824a6650805b369cd4803b0">state().reset_reas</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>reference to a <a class="el" href="structnrfcxx_1_1systemState_1_1state__type.html">state_type</a> instance.</td></tr>
    <tr><td class="paramname">magic</td><td>the application constant used to derive <a class="el" href="structnrfcxx_1_1systemState_1_1state__type.html#a03c5a427ac59f2515160d8ecade07c90" title="A magic number that is used to determine the state is valid.">state_type::magic</a>, which indicates that the state has been properly initialized. A non-random reasonable value would be the timestamp expressed as decimal YYYYMMDDHH, e.g. 2018101310.</td></tr>
    <tr><td class="paramname">app_handler</td><td>optional application handler used to retain application state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab843b93b6888a1e218cd03ebd0b1bc88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab843b93b6888a1e218cd03ebd0b1bc88">&#9670;&nbsp;</a></span>current_pc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t nrfcxx::systemState::current_pc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the address of the instruction after the call. </p>
<p>This is used to provide the location of the reset operation when <a class="el" href="classnrfcxx_1_1systemState.html#aa1d89b282576ca87d1b3daf2a76c8be6" title="Record some information and reset the system.">reset()</a> is invoked. It may be useful in other situations. </p>

</div>
</div>
<a id="a5f0847917050a38c7070711bbaa52379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0847917050a38c7070711bbaa52379">&#9670;&nbsp;</a></span>heap_used()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int nrfcxx::systemState::heap_used </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current total heap allocation. </p>
<p>This delegates to <a class="el" href="system_8h.html#a9472b9eca011b8e7177837e0f923e7eb" title="Return the amount of heap memory currently in use within the system, in bytes.">_nrfcxx_heap_used()</a>. As the block allocator underlying that capability does not release memory it is an accurate reflection of maximum use since startup. </p>

</div>
</div>
<a id="aa0bd491fa43dcd47b6a480ab87d1d09a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0bd491fa43dcd47b6a480ab87d1d09a">&#9670;&nbsp;</a></span>make_scoped_sleeper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classnrfcxx_1_1systemState_1_1scoped__sleeper.html">scoped_sleeper</a> nrfcxx::systemState::make_scoped_sleeper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an RAII object to <a class="el" href="classnrfcxx_1_1systemState_1_1scoped__sleeper.html">track sleep periods</a>. </p>
<p>Example: </p><pre class="fragment">{
  auto sleeper = systemState::make_scoped_sleeper;
  sd_app_evt_wait();
}
</pre> 
</div>
</div>
<a id="ad45135f97a3d2f9f98f49f6e70b25372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45135f97a3d2f9f98f49f6e70b25372">&#9670;&nbsp;</a></span>operationalModeBreakdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t nrfcxx::systemState::operationalModeBreakdown </td>
          <td>(</td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>sleep_utt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>radio_utt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide information on the total time spent in various operations states since reset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">sleep_utt</td><td>the sum of the durations of modes where <a class="el" href="classnrfcxx_1_1systemState.html#ac894d0b0cb64545e01bd2567cb4cc557aa16fc7345f86746bc16dd3c05e63a02a" title="Operational mode flag indicating that CPU is turned off.">OM_SLEEP</a> was set.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">radio_utt</td><td>the sum of the durations of modes where <a class="el" href="classnrfcxx_1_1systemState.html#ac894d0b0cb64545e01bd2567cb4cc557a346b36045c4548ae296f493288970e08" title="Operational mode flag indicating that 2.4 GHz radio is running.">OM_RADIO</a> was set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>total_utt the sum of the durations of all modes. </dd></dl>

</div>
</div>
<a id="aa1d89b282576ca87d1b3daf2a76c8be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d89b282576ca87d1b3daf2a76c8be6">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nrfcxx::systemState::reset </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bypass_watchdog</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Record some information and reset the system. </p>
<p>If <a class="el" href="classnrfcxx_1_1systemState.html#a42f8eaa2ba56e331f1f8cb1fb39c7484" title="Configure the watchdog infrastructure.">watchdogInit()</a> has not been invoked&mdash;or if <code>bypass_watchdog</code> is true&mdash;this delegates to <code>NVIC_SystemReset()</code>, which should produce an immediate reset. However, if the watchdog had been enabled it remains enabled at the start of the next session, which means unless feedings resume in a timely fashion the device may reset unexpectedly.</p>
<p>If <a class="el" href="classnrfcxx_1_1systemState.html#a42f8eaa2ba56e331f1f8cb1fb39c7484" title="Configure the watchdog infrastructure.">watchdogInit()</a> has been invoked and <code>bypass_watchdog</code> is false this disables interrupts and goes to sleep in a loop, allowing the reset to occur due to the watchdog timeout so when the system starts up the watchdog is disabled and can be reprogrammed. In this situation the time before the reset takes effect is determined by the watchdog delay.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>a value to be stored in <a class="el" href="structnrfcxx_1_1systemState_1_1state__type.html#a679b76d94d1e49436141a1500f3300e4" title="Data recording the code passed to reset() in the previous session.">state_type::code</a> after the reset completes.</td></tr>
    <tr><td class="paramname">bypass_watchdog</td><td>if <code>true</code> the reset will take effect immediately even if doing so will leave a running watchdog. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b9a55145d4f906917878dff2df6ea97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b9a55145d4f906917878dff2df6ea97">&#9670;&nbsp;</a></span>sd_fault_handler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void nrfcxx::systemState::sd_fault_handler </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A function suitable for use as the <code>fault_handler</code> argument to <code>sd_softdevice_enable()</code>. </p>
<p>When invoked this causes a system reset where the next session will include <a class="el" href="structnrfcxx_1_1systemState_1_1state__type.html#aae1fc579fb50c98fd91ff58bb00a1a0fa2b45ddecd4fd9ad27b0bec756b93ae02" title="Bit mask for reset_reas to indicate a soft-device fault.">state_type::RESET_REAS_SDFAULT</a> in <a class="el" href="structnrfcxx_1_1systemState_1_1state__type.html#a0026b2d4a824a6650805b369cd4803b0" title="Captured data from NRF_POWER-&gt;RESETREAS.">state_type::reset_reas</a>, the <code>id</code> parameter will be in <a class="el" href="structnrfcxx_1_1systemState_1_1state__type.html#adbf03ce0e55dd905ed84e2d8bc9b87aa" title="Data recording the id of a soft-device fault.">state_type::sdfault_id</a>, the <code>pc</code> parameter will be in <a class="el" href="structnrfcxx_1_1systemState_1_1state__type.html#a2ca90a48cba8b94f545da14542ca8475" title="The program counter at which the reset was initiated.">state_type::last_pc</a>, and the <code>info</code> parameter will be in <a class="el" href="structnrfcxx_1_1systemState_1_1state__type.html#a679b76d94d1e49436141a1500f3300e4" title="Data recording the code passed to reset() in the previous session.">state_type::code</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the SD-specific fault identifier. After reset this value is available from <a class="el" href="structnrfcxx_1_1systemState_1_1state__type.html#adbf03ce0e55dd905ed84e2d8bc9b87aa" title="Data recording the id of a soft-device fault.">state_type::sdfault_id</a>.</td></tr>
    <tr><td class="paramname">pc</td><td>the program counter of the instruction that triggered the fault. After reset this will be in <a class="el" href="structnrfcxx_1_1systemState_1_1state__type.html#a2ca90a48cba8b94f545da14542ca8475" title="The program counter at which the reset was initiated.">state_type::last_pc</a>.</td></tr>
    <tr><td class="paramname">info</td><td>additional fault-specific information. After reset this will be in <a class="el" href="structnrfcxx_1_1systemState_1_1state__type.html#a679b76d94d1e49436141a1500f3300e4" title="Data recording the code passed to reset() in the previous session.">state_type::code</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48e0197f6e31c97fd74e790aa8aa3421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48e0197f6e31c97fd74e790aa8aa3421">&#9670;&nbsp;</a></span>stack_used()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int nrfcxx::systemState::stack_used </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the size of stack region that has been used since startup. </p>
<p>This delegates to <a class="el" href="namespacenrfcxx.html#ad1f7a18a691397ea295b191b5d783cde" title="Check the space between the top of the heap and the current stack pointer for matches to the provided...">stack_infer_highwater()</a>. If the value exceeds <a class="el" href="classnrfcxx_1_1systemState.html#a8c97aa271471657c67fc02f821267092" title="Return the size of the reserved stack region.">stack_reserved()</a> there is a greater chance of stack and heap colliding. </p>

</div>
</div>
<a id="a5e8b76acd0cf4814181f84fb29da9032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e8b76acd0cf4814181f84fb29da9032">&#9670;&nbsp;</a></span>systemOff()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void nrfcxx::systemState::systemOff </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>preserve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>button_psel</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enter system off mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">preserve</td><td>bits from <a class="el" href="structnrfcxx_1_1systemState_1_1state__type.html#a0026b2d4a824a6650805b369cd4803b0" title="Captured data from NRF_POWER-&gt;RESETREAS.">state_type::reset_reas</a> for which the failures from the previous session should be preserved as though they occurred in this session. In decreasing priority this supports <a class="el" href="structnrfcxx_1_1systemState_1_1state__type.html#aae1fc579fb50c98fd91ff58bb00a1a0faf4ab8e25853bf7e77ee8f5b0f620829e" title="Bit mask for reset_reas to indicate a fatal system error from which a reset will not recover.">state_type::RESET_REAS_FAILSAFE</a>, <a class="el" href="structnrfcxx_1_1systemState_1_1state__type.html#aae1fc579fb50c98fd91ff58bb00a1a0fa2b45ddecd4fd9ad27b0bec756b93ae02" title="Bit mask for reset_reas to indicate a soft-device fault.">state_type::RESET_REAS_SDFAULT</a>, <a class="el" href="structnrfcxx_1_1systemState_1_1state__type.html#aae1fc579fb50c98fd91ff58bb00a1a0fabbb7435bb389582bdf26256abacb06d0" title="Bit mask for reset_reas to indicate an application-requested reset.">state_type::RESET_REAS_PROGRAMMATIC</a>.</td></tr>
    <tr><td class="paramname">button_psel</td><td>optional PSEL for a button that will be programmed to issue a DETECT signal that will wake the system from off mode. Pass a negative value to disable wakeups. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ce51653d723f3a75c71896804e3f506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce51653d723f3a75c71896804e3f506">&#9670;&nbsp;</a></span>total_now()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t nrfcxx::systemState::total_now </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the aggregate time since the retained state was reset. </p>
<p>This fetches <a class="el" href="classnrfcxx_1_1clock_1_1uptime.html#a1b07645eb81ce9d3004fcc2b9b038c56" title="Full-range uptime counter.">clock::uptime::now()</a> and adds <a class="el" href="">total_uptime</a> to it if a system_state is registered. </p>

</div>
</div>
<a id="a3d1956a471409a35f2216b7d0836ff40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d1956a471409a35f2216b7d0836ff40">&#9670;&nbsp;</a></span>updateOperationalMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int nrfcxx::systemState::updateOperationalMode </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>om_clear</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>om_set</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the operational mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">om_clear</td><td>bits in the operational mode that are to be turned off. Pass zero to leave all currently set bits set.</td></tr>
    <tr><td class="paramname">om_set</td><td>bits in the operational mode that are to be turned on. Pass zero to leave all currently cleared bits clear.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of uptime clock ticks since the last change to the operational mode.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Because of the resolution of the time tracking variables this function must be invoked at least once every 512 s to ensure that tick counter wraps are measured properly.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnrfcxx_1_1systemState.html#ac894d0b0cb64545e01bd2567cb4cc557aa16fc7345f86746bc16dd3c05e63a02a" title="Operational mode flag indicating that CPU is turned off.">OM_SLEEP</a> </dd>
<dd>
<a class="el" href="classnrfcxx_1_1systemState.html#ac894d0b0cb64545e01bd2567cb4cc557a7b19f58c60fda7e7f8500ac119ce67e1" title="Operational mode flag indicating that high-frequency clock is running.">OM_HFCLK</a> </dd>
<dd>
<a class="el" href="classnrfcxx_1_1systemState.html#ac894d0b0cb64545e01bd2567cb4cc557a346b36045c4548ae296f493288970e08" title="Operational mode flag indicating that 2.4 GHz radio is running.">OM_RADIO</a> </dd></dl>

</div>
</div>
<a id="a0f4ca3525c06e849e0ef0cadef28015f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f4ca3525c06e849e0ef0cadef28015f">&#9670;&nbsp;</a></span>watchdogActive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nrfcxx::systemState::watchdogActive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the watchdog infrastructure is active. </p>
<dl class="section note"><dt>Note</dt><dd>If you want to avoid the overhead of a function call in code that includes &lt;<a class="el" href="impl_8hpp.html" title="Primary header for nrfcxx implementation dependencies.">nrfcxx/impl.hpp</a>&gt; this is functionally equivalent to reading <code>NRF_WDT-&gt;RUNSTATUS</code> </dd></dl>

</div>
</div>
<a id="a16c217b7d69b0ea1d361e5c3e3137c56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c217b7d69b0ea1d361e5c3e3137c56">&#9670;&nbsp;</a></span>watchdogCheckExtended()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nrfcxx::systemState::watchdogCheckExtended </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that the extended watchdog channels are current. </p>
<p>Applications should invoke this within the watchdog peripheral delay to confirm that all extended watchdogs are current. If so, the underlying hardware channel common to those channels is fed.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff all channels are fed. If this returns <code>false</code>, the system will watchdog reset within the current delay. </dd></dl>

</div>
</div>
<a id="a30cba0eff0c252c4ace6c794a9566c0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30cba0eff0c252c4ace6c794a9566c0b">&#9670;&nbsp;</a></span>watchdogFeed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrfcxx::systemState::watchdogFeed </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reload a specific channel in the watchdog. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>the channel to be reloaded. Allowed values range from 0 through 7. To be useful the corresponding bit should have been set in <code>channels</code> when <a class="el" href="classnrfcxx_1_1systemState.html#a42f8eaa2ba56e331f1f8cb1fb39c7484" title="Configure the watchdog infrastructure.">watchdogInit()</a> was invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><p class="startdd">If you want to avoid the overhead of a function call in code that includes &lt;<a class="el" href="impl_8hpp.html" title="Primary header for nrfcxx implementation dependencies.">nrfcxx/impl.hpp</a>&gt; this is functionally equivalent to a bounds-checked execution of: </p><pre class="fragment">NRF_WDT-&gt;RR[channel] = WDT_RR_RR_Reload;
</pre><p class="enddd"></p>
</dd></dl>

</div>
</div>
<a id="a9e6c301a3d4fb11cf2da6053d9073428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e6c301a3d4fb11cf2da6053d9073428">&#9670;&nbsp;</a></span>watchdogFeedMulti()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrfcxx::systemState::watchdogFeedMulti </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>channel_mask</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>As with <a class="el" href="classnrfcxx_1_1systemState.html#a30cba0eff0c252c4ace6c794a9566c0b" title="Reload a specific channel in the watchdog.">watchdogFeed()</a> but feeds multiple channels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_mask</td><td>a bit mask where a set bit indicates a channel index to clear. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42f8eaa2ba56e331f1f8cb1fb39c7484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42f8eaa2ba56e331f1f8cb1fb39c7484">&#9670;&nbsp;</a></span>watchdogInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nrfcxx::systemState::watchdogInit </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>delay_32KiHz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>channel_mask</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>run_in_sleep</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>run_in_debug</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the watchdog infrastructure. </p>
<p>Set up the nRF5 watchdog peripheral and add hooks so that if it fires state will be persisted across the reset.</p>
<p>If the watchdog is already running when this function is invoked and the requested configuration matches the existing configuration then the active channels will be fed and the existing session continued to be used. If the configuration is different from the running configuration <a class="el" href="structnrfcxx_1_1systemState_1_1state__type.html#a0026b2d4a824a6650805b369cd4803b0" title="Captured data from NRF_POWER-&gt;RESETREAS.">state_type::reset_reas</a> will be preserved and the system will wait out the previous watchdog.</p>
<p>After configuration <a class="el" href="classnrfcxx_1_1systemState.html#a30cba0eff0c252c4ace6c794a9566c0b" title="Reload a specific channel in the watchdog.">watchdogFeed()</a> must be invoked for all channels enabled in <code>channel_mask</code> with less than <code>delay_32KiHz</code> intervals or the system will reset.</p>
<p>If <a class="el" href="classnrfcxx_1_1systemState.html#ab557c38ce89f2359e69e0d21dd9e94af" title="Pseudo-channel used to support extended watchdog channels.">WATCHDOG_MASK_EXTENDED</a> is present in <code>channel_mask</code> then the <a class="el" href="classnrfcxx_1_1watchdog__extended__channel.html">watchdog_extended_channel</a> infrastructure is enabled, and <a class="el" href="classnrfcxx_1_1systemState.html#a16c217b7d69b0ea1d361e5c3e3137c56" title="Check that the extended watchdog channels are current.">watchdogCheckExtended()</a> must also be invoked within <code>delay_32KiHz</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delay_32KiHz</td><td>the value to write to <code>NRF_WDT-&gt;CRV</code></td></tr>
    <tr><td class="paramname">channel_mask</td><td>a bit mask identifying which watchdog channels are required to complete a reload. The low 8 bits correspond to the eight available physical watchdog channels. If <a class="el" href="classnrfcxx_1_1systemState.html#ab557c38ce89f2359e69e0d21dd9e94af" title="Pseudo-channel used to support extended watchdog channels.">WATCHDOG_MASK_EXTENDED</a> is included then channel 7 is not available and attempting to enable it will produce <a class="el" href="namespacenrfcxx.html#a0c34d4f67cc579f14cc37908a6045c7eae7bd7892cac98851ed6047797be5ae34" title="Application tried something that isn&#39;t allowed.">FailsafeCode::API_VIOLATION</a>.</td></tr>
    <tr><td class="paramname">run_in_sleep</td><td>if <code>true</code> the watchdog will continue to run while the CPU is inactive.</td></tr>
    <tr><td class="paramname">run_in_debug</td><td>if <code>true</code> the watchdog will continue to run while the CPU is halted through a debug interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if the watchdog is successfully started, or a negative code if the watchdog is not running and could not be started. </dd></dl>

</div>
</div>
<a id="a76c61b6e89968e338c1c12d6979af59c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c61b6e89968e338c1c12d6979af59c">&#9670;&nbsp;</a></span>WFE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void nrfcxx::systemState::WFE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Issue a <code>__WFE</code> instruction that records time spent sleeping. </p>
<p>This invokes <a class="el" href="classnrfcxx_1_1systemState.html#a3d1956a471409a35f2216b7d0836ff40" title="Update the operational mode.">updateOperationalMode()</a> before and after the <code>__WFE</code> passing <a class="el" href="classnrfcxx_1_1systemState.html#ac894d0b0cb64545e01bd2567cb4cc557aa16fc7345f86746bc16dd3c05e63a02a" title="Operational mode flag indicating that CPU is turned off.">OM_SLEEP</a> appropriately to track the sleep time. </p>

</div>
</div>
<a id="a5b631cb9db5b432d8ccaf825ddfc7973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b631cb9db5b432d8ccaf825ddfc7973">&#9670;&nbsp;</a></span>wfe_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int nrfcxx::systemState::wfe_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of times <a class="el" href="classnrfcxx_1_1systemState.html#a76c61b6e89968e338c1c12d6979af59c" title="Issue a __WFE instruction that records time spent sleeping.">WFE()</a> has returned. </p>
<p>In common use the application uses <a class="el" href="classnrfcxx_1_1event__set.html">event_set</a> operations to return to active mode. This is accomplished by using <a class="el" href="classnrfcxx_1_1systemState.html#a76c61b6e89968e338c1c12d6979af59c" title="Issue a __WFE instruction that records time spent sleeping.">WFE()</a> in a loop, and executing the application event loop only if application events are set. Wakeups from ARM events may occur much more frequently, and although <a class="el" href="classnrfcxx_1_1systemState.html#ac894d0b0cb64545e01bd2567cb4cc557aa16fc7345f86746bc16dd3c05e63a02a" title="Operational mode flag indicating that CPU is turned off.">OM_SLEEP</a> is adjusted on each ARM event wakeup the presence of rapidly firing ARM events may be hidden.</p>
<p>Tracking the rate at which this counter increments can reveal these wakeups.</p>
<dl class="section note"><dt>Note</dt><dd>This is a 32-bit counter, and is expected to wrap. </dd></dl>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="abc9f2db2d5d3b6ee0bdd147866f0df35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc9f2db2d5d3b6ee0bdd147866f0df35">&#9670;&nbsp;</a></span>statep_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnrfcxx_1_1systemState_1_1state__type.html">state_type</a>* nrfcxx::systemState::statep_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to the #state_ field of the first <a class="el" href="classnrfcxx_1_1systemState.html#a1f857a749c014b352e2cfee0c839b2f4" title="Set up a wrapper around a cross-reset state object.">systemState</a> instance to be constructed. </p>
<p>This is used by static member functions. </p>

</div>
</div>
<a id="ab557c38ce89f2359e69e0d21dd9e94af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab557c38ce89f2359e69e0d21dd9e94af">&#9670;&nbsp;</a></span>WATCHDOG_MASK_EXTENDED</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto nrfcxx::systemState::WATCHDOG_MASK_EXTENDED = (1U &lt;&lt; 8)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pseudo-channel used to support extended watchdog channels. </p>
<p>Use this in the <code>channel_mask</code> parameter to <a class="el" href="classnrfcxx_1_1systemState.html#a42f8eaa2ba56e331f1f8cb1fb39c7484" title="Configure the watchdog infrastructure.">watchdogInit()</a> to enable the feature. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>nrfcxx/<a class="el" href="core_8hpp_source.html">core.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
