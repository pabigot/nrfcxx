<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nrfcxx: nrfcxx::sensor::ccs811 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">nrfcxx
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
   <div id="projectbrief">C++-17 Framework for Nordic nRF5 Devices</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenrfcxx.html">nrfcxx</a></li><li class="navelem"><a class="el" href="namespacenrfcxx_1_1sensor.html">sensor</a></li><li class="navelem"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html">ccs811</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">nrfcxx::sensor::ccs811 Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Interface to the <a href="https://ams.com/ccs811">ams CCS811</a> indoor air quality sensor.  
 <a href="classnrfcxx_1_1sensor_1_1ccs811.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ccs811_8hpp_source.html">nrfcxx/sensor/ccs811.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for nrfcxx::sensor::ccs811:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classnrfcxx_1_1sensor_1_1ccs811.png" usemap="#nrfcxx::sensor::ccs811_map" alt=""/>
  <map id="nrfcxx::sensor::ccs811_map" name="nrfcxx::sensor::ccs811_map">
<area href="classnrfcxx_1_1lpm_1_1lpsm__capable.html" title="Base (or mixin) class for anything that supports a state_machine." alt="nrfcxx::lpm::lpsm_capable" shape="rect" coords="0,0,155,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrfcxx_1_1sensor_1_1ccs811_1_1iface__config__type.html">iface_config_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure providing the system resources necessary to interact with the CCS811.  <a href="structnrfcxx_1_1sensor_1_1ccs811_1_1iface__config__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrfcxx_1_1sensor_1_1ccs811_1_1observation__beacon__type.html">observation_beacon_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that can be broadcast as a beacon to provide observation data.  <a href="structnrfcxx_1_1sensor_1_1ccs811_1_1observation__beacon__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrfcxx_1_1sensor_1_1ccs811_1_1observations__type.html">observations_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Captured results after an observation.  <a href="structnrfcxx_1_1sensor_1_1ccs811_1_1observations__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrfcxx_1_1sensor_1_1ccs811_1_1persisted__state__type.html">persisted_state_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">State that should be persisted in non-volatile memory using the <a class="el" href="classnrfcxx_1_1utility_1_1Persist.html" title="Class supporting persistence of tagged records to non-volatile memory.">utility::Persist</a> infrastructure.  <a href="structnrfcxx_1_1sensor_1_1ccs811_1_1persisted__state__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrfcxx_1_1sensor_1_1ccs811_1_1retained__state__type.html">retained_state_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure holding retained state of the sensor.  <a href="structnrfcxx_1_1sensor_1_1ccs811_1_1retained__state__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811_1_1scoped__enabler.html">scoped_enabler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class obtained from <a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#aa16e35425088671cc0f4645a9a997bce" title="Construct and return an RAII object that supports TWI interaction.">scoped_enable()</a>.  <a href="classnrfcxx_1_1sensor_1_1ccs811_1_1scoped__enabler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrfcxx_1_1sensor_1_1ccs811_1_1system__beacon__type.html">system_beacon_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that can be broadcast as a beacon to provide detailed system state.  <a href="structnrfcxx_1_1sensor_1_1ccs811_1_1system__beacon__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrfcxx_1_1sensor_1_1ccs811_1_1threshold__s.html">threshold_s</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thresholds for detecting significant changes in readings.  <a href="structnrfcxx_1_1sensor_1_1ccs811_1_1threshold__s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrfcxx_1_1sensor_1_1ccs811_1_1version__s.html">version_s</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aggregate identity and version from hardware and firmware registers.  <a href="structnrfcxx_1_1sensor_1_1ccs811_1_1version__s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a76d59b8bf72d0d68ab5276fcbf38f9e5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a76d59b8bf72d0d68ab5276fcbf38f9e5">STATUS_e</a> : uint16_t { <br />
&#160;&#160;<a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a76d59b8bf72d0d68ab5276fcbf38f9e5ac1923289b79d243733ed876ca3fc0b7d">ST_ERROR</a> = 0x01, 
<a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a76d59b8bf72d0d68ab5276fcbf38f9e5ad46611ace5f1ff9c6c186e506bc3a0be">ST_DATA_READY</a> = 0x08, 
<a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a76d59b8bf72d0d68ab5276fcbf38f9e5acca5882b928dd6ca3f202f773a731b63">ST_APP_VALID</a> = 0x10, 
<a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a76d59b8bf72d0d68ab5276fcbf38f9e5a0ad0b0c6ee5d30752c9eae026c7013d7">ST_APP_VERIFY</a> = 0x20, 
<br />
&#160;&#160;<a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a76d59b8bf72d0d68ab5276fcbf38f9e5ae7be2ced9f8ac073c1af2d85f5803d09">ST_APP_ERASE</a> = 0x40, 
<a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a76d59b8bf72d0d68ab5276fcbf38f9e5a09acca32310e531a341c0252aadf581e">ST_FW_MODE</a> = 0x80, 
<a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a76d59b8bf72d0d68ab5276fcbf38f9e5a1cecdb6d3ca70ba46812d5d85ae4e876">EI_WRITE_REG_INVALID</a> = 0x0100, 
<a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a76d59b8bf72d0d68ab5276fcbf38f9e5a3c0bddf70075b094a3054790474a1b63">EI_READ_REG_INVALID</a> = 0x0200, 
<br />
&#160;&#160;<a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a76d59b8bf72d0d68ab5276fcbf38f9e5affc12dfa0d029294c0d7b195683b7c8b">EI_MEASMODE_INVALID</a> = 0x0400, 
<a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a76d59b8bf72d0d68ab5276fcbf38f9e5a2dbdbd564c058e32d23d96da455ae878">EI_MAX_RESISTANCE</a> = 0x0800, 
<a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a76d59b8bf72d0d68ab5276fcbf38f9e5a095275eb1e5dff1e56d07ce488dae491">EI_HEATER_FAULT</a> = 0x1000, 
<a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a76d59b8bf72d0d68ab5276fcbf38f9e5a79816f48cbf43a748e44d044dffb6ba0">EI_HEATER_SUPPLY</a> = 0x2000
<br />
 }</td></tr>
<tr class="separator:a76d59b8bf72d0d68ab5276fcbf38f9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c52ec083e05210e7aae9128f7fb56a7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a5c52ec083e05210e7aae9128f7fb56a7">DRIVE_MODE_e</a> : uint8_t { <a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a5c52ec083e05210e7aae9128f7fb56a7a054f31ca389fe333cbc75f3420e2488d">DM_IDLE</a> = 0, 
<a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a5c52ec083e05210e7aae9128f7fb56a7a5d76fa2607d5d62274a72f6f8f736aee">DM_1_s</a> = 1, 
<a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a5c52ec083e05210e7aae9128f7fb56a7a68f623a3235867f067b64d3d66fd4a4c">DM_10_s</a> = 2, 
<a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a5c52ec083e05210e7aae9128f7fb56a7ac64888e0cd6290dd2ef84425a0d60b8a">DM_60_s</a> = 3
 }</td></tr>
<tr class="memdesc:a5c52ec083e05210e7aae9128f7fb56a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allowed drive modes for the <code>MEAS_MODE</code> register.  <a href="classnrfcxx_1_1sensor_1_1ccs811.html#a5c52ec083e05210e7aae9128f7fb56a7">More...</a><br /></td></tr>
<tr class="separator:a5c52ec083e05210e7aae9128f7fb56a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328932f17f7819e852473a047403474c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a328932f17f7819e852473a047403474c">status_type</a> = uint16_t</td></tr>
<tr class="memdesc:a328932f17f7819e852473a047403474c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value for a valid CCS811 status.  <a href="#a328932f17f7819e852473a047403474c">More...</a><br /></td></tr>
<tr class="separator:a328932f17f7819e852473a047403474c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad9745d6192405ccd1633637d8b20e297"><td class="memItemLeft" align="right" valign="top"><a id="ad9745d6192405ccd1633637d8b20e297"></a>
const <a class="el" href="structnrfcxx_1_1sensor_1_1ccs811_1_1iface__config__type.html">iface_config_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#ad9745d6192405ccd1633637d8b20e297">iface_config</a> () const</td></tr>
<tr class="memdesc:ad9745d6192405ccd1633637d8b20e297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the interface configuration for the sensor. <br /></td></tr>
<tr class="separator:ad9745d6192405ccd1633637d8b20e297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfafdc80c28a524648a4525a40700237"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#abfafdc80c28a524648a4525a40700237">update_persisted</a> (<a class="el" href="structnrfcxx_1_1sensor_1_1ccs811_1_1persisted__state__type.html">persisted_state_type</a> &amp;ps) const</td></tr>
<tr class="memdesc:abfafdc80c28a524648a4525a40700237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a persisted state with information from retained state.  <a href="#abfafdc80c28a524648a4525a40700237">More...</a><br /></td></tr>
<tr class="separator:abfafdc80c28a524648a4525a40700237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001fc07569d65ddf10757ae9a455e014"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a001fc07569d65ddf10757ae9a455e014">restore_from_persisted</a> (const <a class="el" href="structnrfcxx_1_1sensor_1_1ccs811_1_1persisted__state__type.html">persisted_state_type</a> &amp;ps)</td></tr>
<tr class="memdesc:a001fc07569d65ddf10757ae9a455e014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the retained state with information from persisted state.  <a href="#a001fc07569d65ddf10757ae9a455e014">More...</a><br /></td></tr>
<tr class="separator:a001fc07569d65ddf10757ae9a455e014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5484145a56678b870a60bed05a21c7b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#af5484145a56678b870a60bed05a21c7b">ccs811</a> (<a class="el" href="namespacenrfcxx.html#aec2e5281eceb50c80579cc72a0b42e76">notifier_type</a> setter, <a class="el" href="structnrfcxx_1_1sensor_1_1ccs811_1_1iface__config__type.html">iface_config_type</a> &amp;ifc, bool addr_sec=false)</td></tr>
<tr class="memdesc:af5484145a56678b870a60bed05a21c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiate the device.  <a href="#af5484145a56678b870a60bed05a21c7b">More...</a><br /></td></tr>
<tr class="separator:af5484145a56678b870a60bed05a21c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5abadffd2029bc8a64cbe1bab687d5a5"><td class="memItemLeft" align="right" valign="top"><a id="a5abadffd2029bc8a64cbe1bab687d5a5"></a>
<a class="el" href="classnrfcxx_1_1periph_1_1TWI.html">periph::TWI</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a5abadffd2029bc8a64cbe1bab687d5a5">twi</a> () const</td></tr>
<tr class="memdesc:a5abadffd2029bc8a64cbe1bab687d5a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directly access the TWI peripheral used to communicate with the device. <br /></td></tr>
<tr class="separator:a5abadffd2029bc8a64cbe1bab687d5a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1991a3feded88d139e3ca081ed77120e"><td class="memItemLeft" align="right" valign="top"><a id="a1991a3feded88d139e3ca081ed77120e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a1991a3feded88d139e3ca081ed77120e">intn_asserted</a> () const</td></tr>
<tr class="memdesc:a1991a3feded88d139e3ca081ed77120e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programmatic test for whether <code>INTn</code> is asserted. <br /></td></tr>
<tr class="separator:a1991a3feded88d139e3ca081ed77120e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16e35425088671cc0f4645a9a997bce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811_1_1scoped__enabler.html">scoped_enabler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#aa16e35425088671cc0f4645a9a997bce">scoped_enable</a> () const</td></tr>
<tr class="memdesc:aa16e35425088671cc0f4645a9a997bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and return an RAII object that supports TWI interaction.  <a href="#aa16e35425088671cc0f4645a9a997bce">More...</a><br /></td></tr>
<tr class="separator:aa16e35425088671cc0f4645a9a997bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f043ae708d1f1b855dd78309916c0e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a97f043ae708d1f1b855dd78309916c0e">reset</a> () const</td></tr>
<tr class="memdesc:a97f043ae708d1f1b855dd78309916c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the RESETn line to reset the sensor.  <a href="#a97f043ae708d1f1b855dd78309916c0e">More...</a><br /></td></tr>
<tr class="separator:a97f043ae708d1f1b855dd78309916c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7538494795381638f243340a516046e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#ab7538494795381638f243340a516046e">id_version</a> (<a class="el" href="structnrfcxx_1_1sensor_1_1ccs811_1_1version__s.html">version_s</a> &amp;vid) const</td></tr>
<tr class="memdesc:ab7538494795381638f243340a516046e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the device hardware and firmware identity and version.  <a href="#ab7538494795381638f243340a516046e">More...</a><br /></td></tr>
<tr class="separator:ab7538494795381638f243340a516046e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d4cd3d18293256c8a1780fdc438e56"><td class="memItemLeft" align="right" valign="top"><a id="a14d4cd3d18293256c8a1780fdc438e56"></a>
const <a class="el" href="structnrfcxx_1_1sensor_1_1ccs811_1_1version__s.html">version_s</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a14d4cd3d18293256c8a1780fdc438e56">id_version</a> () const</td></tr>
<tr class="memdesc:a14d4cd3d18293256c8a1780fdc438e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the version state managed by the LPM machine. <br /></td></tr>
<tr class="separator:a14d4cd3d18293256c8a1780fdc438e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064fb16441c15508de7cb34b6ea0d675"><td class="memItemLeft" align="right" valign="top"><a id="a064fb16441c15508de7cb34b6ea0d675"></a>
const <a class="el" href="structnrfcxx_1_1sensor_1_1ccs811_1_1observations__type.html">observations_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a064fb16441c15508de7cb34b6ea0d675">observations</a> () const</td></tr>
<tr class="memdesc:a064fb16441c15508de7cb34b6ea0d675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the most recent collected observations. <br /></td></tr>
<tr class="separator:a064fb16441c15508de7cb34b6ea0d675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa405dd673b6d303c973ba873b306ff70"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#aa405dd673b6d303c973ba873b306ff70">fill_system_beacon</a> (<a class="el" href="structnrfcxx_1_1sensor_1_1ccs811_1_1system__beacon__type.html">system_beacon_type</a> &amp;fr) const</td></tr>
<tr class="memdesc:aa405dd673b6d303c973ba873b306ff70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the contents of a system beacon frame.  <a href="#aa405dd673b6d303c973ba873b306ff70">More...</a><br /></td></tr>
<tr class="separator:aa405dd673b6d303c973ba873b306ff70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1cd7232128d9b7d081ed3ec537a3fd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnrfcxx_1_1sensor_1_1ccs811_1_1observation__beacon__type.html">observation_beacon_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#aa1cd7232128d9b7d081ed3ec537a3fd5">observation_beacon</a> () const</td></tr>
<tr class="memdesc:aa1cd7232128d9b7d081ed3ec537a3fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate and return an observation beacon structure from the current state.  <a href="#aa1cd7232128d9b7d081ed3ec537a3fd5">More...</a><br /></td></tr>
<tr class="separator:aa1cd7232128d9b7d081ed3ec537a3fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04674097e89d833dbf94556f71c6355"><td class="memItemLeft" align="right" valign="top"><a id="af04674097e89d833dbf94556f71c6355"></a>
const <a class="el" href="classnrfcxx_1_1lpm_1_1state__machine.html">lpm::state_machine</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#af04674097e89d833dbf94556f71c6355">machine</a> () const</td></tr>
<tr class="memdesc:af04674097e89d833dbf94556f71c6355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gain read-only access to the LPM machine state. <br /></td></tr>
<tr class="separator:af04674097e89d833dbf94556f71c6355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eeb285bbffb06fb0a33c95c8f632504"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a6eeb285bbffb06fb0a33c95c8f632504">status</a> () const</td></tr>
<tr class="memdesc:a6eeb285bbffb06fb0a33c95c8f632504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the <code>STATUS</code> and, if necessary, <code>ERROR_ID</code> registers.  <a href="#a6eeb285bbffb06fb0a33c95c8f632504">More...</a><br /></td></tr>
<tr class="separator:a6eeb285bbffb06fb0a33c95c8f632504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc6399ed678a752a86bba0af34e376a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a5cc6399ed678a752a86bba0af34e376a">env_data</a> (uint32_t enc)</td></tr>
<tr class="memdesc:a5cc6399ed678a752a86bba0af34e376a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the environment data structure.  <a href="#a5cc6399ed678a752a86bba0af34e376a">More...</a><br /></td></tr>
<tr class="separator:a5cc6399ed678a752a86bba0af34e376a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba800d3ca2dd87c1acae89ecfade4a4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a2ba800d3ca2dd87c1acae89ecfade4a4">env_data</a> () const</td></tr>
<tr class="memdesc:a2ba800d3ca2dd87c1acae89ecfade4a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the last written environment data setting.  <a href="#a2ba800d3ca2dd87c1acae89ecfade4a4">More...</a><br /></td></tr>
<tr class="separator:a2ba800d3ca2dd87c1acae89ecfade4a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691cf861296b4b4c28caa87e77830111"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a691cf861296b4b4c28caa87e77830111">baseline</a> () const</td></tr>
<tr class="memdesc:a691cf861296b4b4c28caa87e77830111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the current baseline value.  <a href="#a691cf861296b4b4c28caa87e77830111">More...</a><br /></td></tr>
<tr class="separator:a691cf861296b4b4c28caa87e77830111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29beafd205c9811abb7434c3641c366d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a29beafd205c9811abb7434c3641c366d">baseline</a> (uint16_t value) const</td></tr>
<tr class="memdesc:a29beafd205c9811abb7434c3641c366d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the baseline value.  <a href="#a29beafd205c9811abb7434c3641c366d">More...</a><br /></td></tr>
<tr class="separator:a29beafd205c9811abb7434c3641c366d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa384e91652ccc6da2a02c8005c3e8db9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#aa384e91652ccc6da2a02c8005c3e8db9">retain_baseline</a> ()</td></tr>
<tr class="memdesc:aa384e91652ccc6da2a02c8005c3e8db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record the current baseline in retained state.  <a href="#aa384e91652ccc6da2a02c8005c3e8db9">More...</a><br /></td></tr>
<tr class="separator:aa384e91652ccc6da2a02c8005c3e8db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0c8e0fa353445e814f954687b2e11a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a8e0c8e0fa353445e814f954687b2e11a">active_drive_mode</a> () const</td></tr>
<tr class="memdesc:a8e0c8e0fa353445e814f954687b2e11a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the drive mode from the active state.  <a href="#a8e0c8e0fa353445e814f954687b2e11a">More...</a><br /></td></tr>
<tr class="separator:a8e0c8e0fa353445e814f954687b2e11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7450897e4d3f72b7e396659821bee3d7"><td class="memItemLeft" align="right" valign="top"><a id="a7450897e4d3f72b7e396659821bee3d7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a7450897e4d3f72b7e396659821bee3d7">drive_mode</a> () const</td></tr>
<tr class="memdesc:a7450897e4d3f72b7e396659821bee3d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the configured drive mode. <br /></td></tr>
<tr class="separator:a7450897e4d3f72b7e396659821bee3d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d067b2d88fd9dba260392e94a81ba1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a12d067b2d88fd9dba260392e94a81ba1">drive_mode</a> (unsigned int dm)</td></tr>
<tr class="memdesc:a12d067b2d88fd9dba260392e94a81ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the drive mode.  <a href="#a12d067b2d88fd9dba260392e94a81ba1">More...</a><br /></td></tr>
<tr class="separator:a12d067b2d88fd9dba260392e94a81ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2686ec447b4fb163189ad252a76cc63"><td class="memItemLeft" align="right" valign="top"><a id="af2686ec447b4fb163189ad252a76cc63"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#af2686ec447b4fb163189ad252a76cc63">i2c_address</a> () const</td></tr>
<tr class="memdesc:af2686ec447b4fb163189ad252a76cc63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the I2C address used for the device. <br /></td></tr>
<tr class="separator:af2686ec447b4fb163189ad252a76cc63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classnrfcxx_1_1lpm_1_1lpsm__capable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classnrfcxx_1_1lpm_1_1lpsm__capable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classnrfcxx_1_1lpm_1_1lpsm__capable.html">nrfcxx::lpm::lpsm_capable</a></td></tr>
<tr class="memitem:ab40c73125317a1e2f4bd6f0faba6f6a8 inherit pub_methods_classnrfcxx_1_1lpm_1_1lpsm__capable"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1lpm_1_1lpsm__capable.html#ab40c73125317a1e2f4bd6f0faba6f6a8">lpsm_start</a> ()</td></tr>
<tr class="memdesc:ab40c73125317a1e2f4bd6f0faba6f6a8 inherit pub_methods_classnrfcxx_1_1lpm_1_1lpsm__capable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate and prepare to initiate an LPM collection.  <a href="classnrfcxx_1_1lpm_1_1lpsm__capable.html#ab40c73125317a1e2f4bd6f0faba6f6a8">More...</a><br /></td></tr>
<tr class="separator:ab40c73125317a1e2f4bd6f0faba6f6a8 inherit pub_methods_classnrfcxx_1_1lpm_1_1lpsm__capable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dfab0d941f711be66bdb02b2642336b inherit pub_methods_classnrfcxx_1_1lpm_1_1lpsm__capable"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1lpm_1_1lpsm__capable.html#a9dfab0d941f711be66bdb02b2642336b">lpsm_sample</a> ()</td></tr>
<tr class="memdesc:a9dfab0d941f711be66bdb02b2642336b inherit pub_methods_classnrfcxx_1_1lpm_1_1lpsm__capable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask the LPM infrastructure to initiate a new sample.  <a href="classnrfcxx_1_1lpm_1_1lpsm__capable.html#a9dfab0d941f711be66bdb02b2642336b">More...</a><br /></td></tr>
<tr class="separator:a9dfab0d941f711be66bdb02b2642336b inherit pub_methods_classnrfcxx_1_1lpm_1_1lpsm__capable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34edb4653186ab238b357b77830b22e3 inherit pub_methods_classnrfcxx_1_1lpm_1_1lpsm__capable"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnrfcxx_1_1lpm_1_1state__machine.html#ad3c59b1f289e97f451b815fcc001ebb9">lpm::state_machine::process_flags_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1lpm_1_1lpsm__capable.html#a34edb4653186ab238b357b77830b22e3">lpsm_process</a> ()</td></tr>
<tr class="memdesc:a34edb4653186ab238b357b77830b22e3 inherit pub_methods_classnrfcxx_1_1lpm_1_1lpsm__capable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make progress on an LPM collection.  <a href="classnrfcxx_1_1lpm_1_1lpsm__capable.html#a34edb4653186ab238b357b77830b22e3">More...</a><br /></td></tr>
<tr class="separator:a34edb4653186ab238b357b77830b22e3 inherit pub_methods_classnrfcxx_1_1lpm_1_1lpsm__capable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d4f6beb43b3cf9dbc77b3c3849aa0d inherit pub_methods_classnrfcxx_1_1lpm_1_1lpsm__capable"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1lpm_1_1lpsm__capable.html#a42d4f6beb43b3cf9dbc77b3c3849aa0d">lpsm_stop</a> ()</td></tr>
<tr class="separator:a42d4f6beb43b3cf9dbc77b3c3849aa0d inherit pub_methods_classnrfcxx_1_1lpm_1_1lpsm__capable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7584a9be0eecf5c3738c7df96ef71ebc inherit pub_methods_classnrfcxx_1_1lpm_1_1lpsm__capable"><td class="memItemLeft" align="right" valign="top"><a id="a7584a9be0eecf5c3738c7df96ef71ebc"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>lpsm_reset</b> ()</td></tr>
<tr class="separator:a7584a9be0eecf5c3738c7df96ef71ebc inherit pub_methods_classnrfcxx_1_1lpm_1_1lpsm__capable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fed75b260df1179221fbd931342dd1e inherit pub_methods_classnrfcxx_1_1lpm_1_1lpsm__capable"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1lpm_1_1lpsm__capable.html#a7fed75b260df1179221fbd931342dd1e">lpsm_process_rc</a> () const</td></tr>
<tr class="memdesc:a7fed75b260df1179221fbd931342dd1e inherit pub_methods_classnrfcxx_1_1lpm_1_1lpsm__capable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the internal result code from the last invocation of <a class="el" href="classnrfcxx_1_1lpm_1_1lpsm__capable.html#af248c4adaf5ee6cc6e7c9d172dea55d1" title="Override to implement machine-specific operations of lpsm_process().">lpsm_process_()</a>.  <a href="classnrfcxx_1_1lpm_1_1lpsm__capable.html#a7fed75b260df1179221fbd931342dd1e">More...</a><br /></td></tr>
<tr class="separator:a7fed75b260df1179221fbd931342dd1e inherit pub_methods_classnrfcxx_1_1lpm_1_1lpsm__capable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1282fa837cf2325671fb889787b9351b inherit pub_methods_classnrfcxx_1_1lpm_1_1lpsm__capable"><td class="memItemLeft" align="right" valign="top"><a id="a1282fa837cf2325671fb889787b9351b"></a>
const <a class="el" href="classnrfcxx_1_1lpm_1_1state__machine.html">lpm::state_machine</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1lpm_1_1lpsm__capable.html#a1282fa837cf2325671fb889787b9351b">machine</a> () const</td></tr>
<tr class="memdesc:a1282fa837cf2325671fb889787b9351b inherit pub_methods_classnrfcxx_1_1lpm_1_1lpsm__capable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gain read-only access to the LPM machine state. <br /></td></tr>
<tr class="separator:a1282fa837cf2325671fb889787b9351b inherit pub_methods_classnrfcxx_1_1lpm_1_1lpsm__capable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a6e282d6bc5a2cfcbeda36812d218ea7c"><td class="memItemLeft" align="right" valign="top"><a id="a6e282d6bc5a2cfcbeda36812d218ea7c"></a>
static const <a class="el" href="structnrfcxx_1_1sensor_1_1ccs811_1_1retained__state__type.html">retained_state_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a6e282d6bc5a2cfcbeda36812d218ea7c">retained_state</a> ()</td></tr>
<tr class="memdesc:a6e282d6bc5a2cfcbeda36812d218ea7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the retained state. <br /></td></tr>
<tr class="separator:a6e282d6bc5a2cfcbeda36812d218ea7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7141846e808f392b1800b1b027a5a83"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#ab7141846e808f392b1800b1b027a5a83">state_setup</a> (const <a class="el" href="structnrfcxx_1_1systemState_1_1state__type.html">systemState::state_type</a> &amp;ss, bool is_reset, bool retained)</td></tr>
<tr class="memdesc:ab7141846e808f392b1800b1b027a5a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to maintain CCS811 state across resets.  <a href="#ab7141846e808f392b1800b1b027a5a83">More...</a><br /></td></tr>
<tr class="separator:ab7141846e808f392b1800b1b027a5a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdfa9a9ef1aa43839d80e58c7531f015"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#acdfa9a9ef1aa43839d80e58c7531f015">encode_env</a> (int16_t temp_cCel, uint16_t rh_pptt)</td></tr>
<tr class="memdesc:acdfa9a9ef1aa43839d80e58c7531f015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert temperature and humidity to CCS811 <code>ENV_DATA</code> format.  <a href="#acdfa9a9ef1aa43839d80e58c7531f015">More...</a><br /></td></tr>
<tr class="separator:acdfa9a9ef1aa43839d80e58c7531f015"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a53869551e748fdfb39a5f487d4a2af7b"><td class="memItemLeft" align="right" valign="top"><a id="a53869551e748fdfb39a5f487d4a2af7b"></a>
static constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a53869551e748fdfb39a5f487d4a2af7b">APP_START_DELAY_utt</a> = <a class="el" href="classnrfcxx_1_1clock_1_1uptime.html#aeea6fc0350de514e5d8772189748d35c">clock::uptime::from_ms</a>(1U)</td></tr>
<tr class="memdesc:a53869551e748fdfb39a5f487d4a2af7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value for maximum t_APP_START in uptime ticks. <br /></td></tr>
<tr class="separator:a53869551e748fdfb39a5f487d4a2af7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07caa33d93e02e7ddf00e2bb6269705d"><td class="memItemLeft" align="right" valign="top"><a id="a07caa33d93e02e7ddf00e2bb6269705d"></a>
static constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a07caa33d93e02e7ddf00e2bb6269705d">WAKE_DELAY_us</a> = 50U</td></tr>
<tr class="memdesc:a07caa33d93e02e7ddf00e2bb6269705d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value for maximum t_WAKE in microseconds. <br /></td></tr>
<tr class="separator:a07caa33d93e02e7ddf00e2bb6269705d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5a53d4c370245bd007d511d11bb3fd"><td class="memItemLeft" align="right" valign="top"><a id="a0e5a53d4c370245bd007d511d11bb3fd"></a>
static constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a0e5a53d4c370245bd007d511d11bb3fd">COLD_START_DELAY_utt</a> = <a class="el" href="classnrfcxx_1_1clock_1_1uptime.html#aeea6fc0350de514e5d8772189748d35c">clock::uptime::from_ms</a>(20U)</td></tr>
<tr class="memdesc:a0e5a53d4c370245bd007d511d11bb3fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value for maximum t_START after power-on in uptime ticks. <br /></td></tr>
<tr class="separator:a0e5a53d4c370245bd007d511d11bb3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d263481aa731f4a35101e953188acf1"><td class="memItemLeft" align="right" valign="top"><a id="a2d263481aa731f4a35101e953188acf1"></a>
static constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a2d263481aa731f4a35101e953188acf1">WARM_START_DELAY_utt</a> = <a class="el" href="classnrfcxx_1_1clock_1_1uptime.html#aeea6fc0350de514e5d8772189748d35c">clock::uptime::from_ms</a>(2U)</td></tr>
<tr class="memdesc:a2d263481aa731f4a35101e953188acf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value for maximum t_START after reset in uptime ticks. <br /></td></tr>
<tr class="separator:a2d263481aa731f4a35101e953188acf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22320c6ab5d31e77cfa30c63f024e65"><td class="memItemLeft" align="right" valign="top"><a id="ae22320c6ab5d31e77cfa30c63f024e65"></a>
static constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#ae22320c6ab5d31e77cfa30c63f024e65">DWAKE_DELAY_us</a> = 20U</td></tr>
<tr class="memdesc:ae22320c6ab5d31e77cfa30c63f024e65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value for minimum t_DWAKE in microseconds. <br /></td></tr>
<tr class="separator:ae22320c6ab5d31e77cfa30c63f024e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f8d2e2e5b333847e6c942b3f9d6eb0"><td class="memItemLeft" align="right" valign="top"><a id="a49f8d2e2e5b333847e6c942b3f9d6eb0"></a>
static constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a49f8d2e2e5b333847e6c942b3f9d6eb0">DRESET_DELAY_us</a> = 20U</td></tr>
<tr class="memdesc:a49f8d2e2e5b333847e6c942b3f9d6eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value for minimum t_DRESET in microseconds. <br /></td></tr>
<tr class="separator:a49f8d2e2e5b333847e6c942b3f9d6eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89883c98ad16213f1808a06682b1dae1"><td class="memItemLeft" align="right" valign="top"><a id="a89883c98ad16213f1808a06682b1dae1"></a>
static constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a89883c98ad16213f1808a06682b1dae1">RESET_DELAY_us</a> = 15U</td></tr>
<tr class="memdesc:a89883c98ad16213f1808a06682b1dae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value for minimum t_RESET in microseconds. <br /></td></tr>
<tr class="separator:a89883c98ad16213f1808a06682b1dae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a939ed1844b895a4b65df1ec31a2ebd97"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a939ed1844b895a4b65df1ec31a2ebd97">CONDITIONING_DELAY_utt</a> = 20U * 60U * clock::uptime::Frequency_Hz</td></tr>
<tr class="memdesc:a939ed1844b895a4b65df1ec31a2ebd97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duration of the conditioning period, in uptime ticks.  <a href="#a939ed1844b895a4b65df1ec31a2ebd97">More...</a><br /></td></tr>
<tr class="separator:a939ed1844b895a4b65df1ec31a2ebd97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589e57ccdc9e11df78dec73ad4b8be62"><td class="memItemLeft" align="right" valign="top"><a id="a589e57ccdc9e11df78dec73ad4b8be62"></a>
static constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a589e57ccdc9e11df78dec73ad4b8be62">BASELINE_CAPTURE_INTERVAL_utt</a> = 24U * 60U * 60U * clock::uptime::Frequency_Hz</td></tr>
<tr class="memdesc:a589e57ccdc9e11df78dec73ad4b8be62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duration between retention of the <code>BASELINE</code> register. <br /></td></tr>
<tr class="separator:a589e57ccdc9e11df78dec73ad4b8be62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf65f7bd48fea4be9d64cc00b3c27beb"><td class="memItemLeft" align="right" valign="top"><a id="acf65f7bd48fea4be9d64cc00b3c27beb"></a>
static constexpr uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#acf65f7bd48fea4be9d64cc00b3c27beb">HARDWARE_ID</a> = 0x81</td></tr>
<tr class="memdesc:acf65f7bd48fea4be9d64cc00b3c27beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value expected to be read back in <a class="el" href="structnrfcxx_1_1sensor_1_1ccs811_1_1version__s.html#a10a83a9e929c34f548ed6be072a88cbd" title="Hardware identifer, which should be HARDWARE_ID.">version_s::hw_id</a>. <br /></td></tr>
<tr class="separator:acf65f7bd48fea4be9d64cc00b3c27beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd13b7be47031e3a639c2a6d10058a7"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a9fd13b7be47031e3a639c2a6d10058a7">PF_REPORTING</a> = <a class="el" href="classnrfcxx_1_1lpm_1_1state__machine.html#ac318c7a59857181f6bc9a9aae7f0d4ad">lpm::state_machine::PF_APP_BASE</a> &lt;&lt; 0</td></tr>
<tr class="memdesc:a9fd13b7be47031e3a639c2a6d10058a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit set in non-negative <a class="el" href="classnrfcxx_1_1lpm_1_1lpsm__capable.html#a34edb4653186ab238b357b77830b22e3" title="Make progress on an LPM collection.">lpsm_process()</a> result when the sensor has started providing observations.  <a href="#a9fd13b7be47031e3a639c2a6d10058a7">More...</a><br /></td></tr>
<tr class="separator:a9fd13b7be47031e3a639c2a6d10058a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b5d51b7608bb5c247e1710d3483584"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a64b5d51b7608bb5c247e1710d3483584">PF_RESTORED</a> = <a class="el" href="classnrfcxx_1_1lpm_1_1state__machine.html#ac318c7a59857181f6bc9a9aae7f0d4ad">lpm::state_machine::PF_APP_BASE</a> &lt;&lt; 1</td></tr>
<tr class="memdesc:a64b5d51b7608bb5c247e1710d3483584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit set in non-negative <a class="el" href="classnrfcxx_1_1lpm_1_1lpsm__capable.html#a34edb4653186ab238b357b77830b22e3" title="Make progress on an LPM collection.">lpsm_process()</a> result when the machine updated the CCS811 baseline from retained state.  <a href="#a64b5d51b7608bb5c247e1710d3483584">More...</a><br /></td></tr>
<tr class="separator:a64b5d51b7608bb5c247e1710d3483584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831c2ade5276abb3d3c61ae45d00f1cd"><td class="memItemLeft" align="right" valign="top"><a id="a831c2ade5276abb3d3c61ae45d00f1cd"></a>
static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a831c2ade5276abb3d3c61ae45d00f1cd">PF_CONDITIONED</a> = <a class="el" href="classnrfcxx_1_1lpm_1_1state__machine.html#ac318c7a59857181f6bc9a9aae7f0d4ad">lpm::state_machine::PF_APP_BASE</a> &lt;&lt; 2</td></tr>
<tr class="memdesc:a831c2ade5276abb3d3c61ae45d00f1cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit set in non-negative <a class="el" href="classnrfcxx_1_1lpm_1_1lpsm__capable.html#a34edb4653186ab238b357b77830b22e3" title="Make progress on an LPM collection.">lpsm_process()</a> result when the sensor has completed its conditioning period. <br /></td></tr>
<tr class="separator:a831c2ade5276abb3d3c61ae45d00f1cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa883c87d18d08206483ab8779e43e4"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a4fa883c87d18d08206483ab8779e43e4">PF_BASELINED</a> = <a class="el" href="classnrfcxx_1_1lpm_1_1state__machine.html#ac318c7a59857181f6bc9a9aae7f0d4ad">lpm::state_machine::PF_APP_BASE</a> &lt;&lt; 3</td></tr>
<tr class="memdesc:a4fa883c87d18d08206483ab8779e43e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit set in non-negative <a class="el" href="classnrfcxx_1_1lpm_1_1lpsm__capable.html#a34edb4653186ab238b357b77830b22e3" title="Make progress on an LPM collection.">lpsm_process()</a> result when the machine saved the <code>BASELINE</code> register to retained state.  <a href="#a4fa883c87d18d08206483ab8779e43e4">More...</a><br /></td></tr>
<tr class="separator:a4fa883c87d18d08206483ab8779e43e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade86615b05d390611f64db49cc7ac25f"><td class="memItemLeft" align="right" valign="top"><a id="ade86615b05d390611f64db49cc7ac25f"></a>
static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#ade86615b05d390611f64db49cc7ac25f">PF_CCS811_ERROR</a> = <a class="el" href="classnrfcxx_1_1lpm_1_1state__machine.html#ac318c7a59857181f6bc9a9aae7f0d4ad">lpm::state_machine::PF_APP_BASE</a> &lt;&lt; 4</td></tr>
<tr class="memdesc:ade86615b05d390611f64db49cc7ac25f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit set in non-negative <a class="el" href="classnrfcxx_1_1lpm_1_1lpsm__capable.html#a34edb4653186ab238b357b77830b22e3" title="Make progress on an LPM collection.">lpsm_process()</a> result when a new observation identifies a CCS811 error in <a class="el" href="structnrfcxx_1_1sensor_1_1ccs811_1_1observations__type.html#abd9e39ac91b7bede9351fedda65395ac" title="The combined STATUS and ERROR_ID register values.">observations_type::status</a>. <br /></td></tr>
<tr class="separator:ade86615b05d390611f64db49cc7ac25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755a20db7c76a1454222fe975fa8b8e5"><td class="memItemLeft" align="right" valign="top"><a id="a755a20db7c76a1454222fe975fa8b8e5"></a>
static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a755a20db7c76a1454222fe975fa8b8e5">DEFAULT_DRIVE_MODE</a> = <a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a5c52ec083e05210e7aae9128f7fb56a7a68f623a3235867f067b64d3d66fd4a4c">DM_10_s</a></td></tr>
<tr class="memdesc:a755a20db7c76a1454222fe975fa8b8e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default value for <a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a7450897e4d3f72b7e396659821bee3d7" title="Read the configured drive mode.">drive_mode()</a> <br /></td></tr>
<tr class="separator:a755a20db7c76a1454222fe975fa8b8e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_types_classnrfcxx_1_1lpm_1_1lpsm__capable"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classnrfcxx_1_1lpm_1_1lpsm__capable')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classnrfcxx_1_1lpm_1_1lpsm__capable.html">nrfcxx::lpm::lpsm_capable</a></td></tr>
<tr class="memitem:a500b036dcf6b1a33276c5b17c61ecb31 inherit pro_types_classnrfcxx_1_1lpm_1_1lpsm__capable"><td class="memItemLeft" align="right" valign="top"><a id="a500b036dcf6b1a33276c5b17c61ecb31"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>state_type</b> = <a class="el" href="classnrfcxx_1_1lpm_1_1state__machine.html#af2ca8779e82c34676e98903014dcff7d">state_machine::state_type</a></td></tr>
<tr class="separator:a500b036dcf6b1a33276c5b17c61ecb31 inherit pro_types_classnrfcxx_1_1lpm_1_1lpsm__capable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0242cc797ccbd3271df7415314897eb5 inherit pro_types_classnrfcxx_1_1lpm_1_1lpsm__capable"><td class="memItemLeft" align="right" valign="top"><a id="a0242cc797ccbd3271df7415314897eb5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>process_flags_type</b> = <a class="el" href="classnrfcxx_1_1lpm_1_1state__machine.html#ad3c59b1f289e97f451b815fcc001ebb9">state_machine::process_flags_type</a></td></tr>
<tr class="separator:a0242cc797ccbd3271df7415314897eb5 inherit pro_types_classnrfcxx_1_1lpm_1_1lpsm__capable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classnrfcxx_1_1lpm_1_1lpsm__capable"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classnrfcxx_1_1lpm_1_1lpsm__capable')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classnrfcxx_1_1lpm_1_1lpsm__capable.html">nrfcxx::lpm::lpsm_capable</a></td></tr>
<tr class="memitem:a49ceddad12610b297ff7acf3a836ed3c inherit pro_methods_classnrfcxx_1_1lpm_1_1lpsm__capable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1lpm_1_1lpsm__capable.html#a49ceddad12610b297ff7acf3a836ed3c">lpsm_capable</a> (<a class="el" href="namespacenrfcxx.html#aec2e5281eceb50c80579cc72a0b42e76">notifier_type</a> notify)</td></tr>
<tr class="memdesc:a49ceddad12610b297ff7acf3a836ed3c inherit pro_methods_classnrfcxx_1_1lpm_1_1lpsm__capable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a state machine that records state and supports delayed transitions.  <a href="classnrfcxx_1_1lpm_1_1lpsm__capable.html#a49ceddad12610b297ff7acf3a836ed3c">More...</a><br /></td></tr>
<tr class="separator:a49ceddad12610b297ff7acf3a836ed3c inherit pro_methods_classnrfcxx_1_1lpm_1_1lpsm__capable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af248c4adaf5ee6cc6e7c9d172dea55d1 inherit pro_methods_classnrfcxx_1_1lpm_1_1lpsm__capable"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1lpm_1_1lpsm__capable.html#af248c4adaf5ee6cc6e7c9d172dea55d1">lpsm_process_</a> (int &amp;delay, process_flags_type &amp;pf)</td></tr>
<tr class="memdesc:af248c4adaf5ee6cc6e7c9d172dea55d1 inherit pro_methods_classnrfcxx_1_1lpm_1_1lpsm__capable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override to implement machine-specific operations of <a class="el" href="classnrfcxx_1_1lpm_1_1lpsm__capable.html#a34edb4653186ab238b357b77830b22e3" title="Make progress on an LPM collection.">lpsm_process()</a>.  <a href="classnrfcxx_1_1lpm_1_1lpsm__capable.html#af248c4adaf5ee6cc6e7c9d172dea55d1">More...</a><br /></td></tr>
<tr class="separator:af248c4adaf5ee6cc6e7c9d172dea55d1 inherit pro_methods_classnrfcxx_1_1lpm_1_1lpsm__capable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f580ed4d65fb7a46aa269bc250f2bc2 inherit pro_methods_classnrfcxx_1_1lpm_1_1lpsm__capable"><td class="memItemLeft" align="right" valign="top"><a id="a8f580ed4d65fb7a46aa269bc250f2bc2"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1lpm_1_1lpsm__capable.html#a8f580ed4d65fb7a46aa269bc250f2bc2">lpsm_reset_</a> ()</td></tr>
<tr class="memdesc:a8f580ed4d65fb7a46aa269bc250f2bc2 inherit pro_methods_classnrfcxx_1_1lpm_1_1lpsm__capable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override to reset state that is held outside the machine. <br /></td></tr>
<tr class="separator:a8f580ed4d65fb7a46aa269bc250f2bc2 inherit pro_methods_classnrfcxx_1_1lpm_1_1lpsm__capable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classnrfcxx_1_1lpm_1_1lpsm__capable"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classnrfcxx_1_1lpm_1_1lpsm__capable')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classnrfcxx_1_1lpm_1_1lpsm__capable.html">nrfcxx::lpm::lpsm_capable</a></td></tr>
<tr class="memitem:a277409f26e173126132bcd0cf35070a6 inherit pro_attribs_classnrfcxx_1_1lpm_1_1lpsm__capable"><td class="memItemLeft" align="right" valign="top"><a id="a277409f26e173126132bcd0cf35070a6"></a>
<a class="el" href="classnrfcxx_1_1lpm_1_1state__machine.html">state_machine</a>&#160;</td><td class="memItemRight" valign="bottom"><b>machine_</b></td></tr>
<tr class="separator:a277409f26e173126132bcd0cf35070a6 inherit pro_attribs_classnrfcxx_1_1lpm_1_1lpsm__capable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interface to the <a href="https://ams.com/ccs811">ams CCS811</a> indoor air quality sensor. </p>
<dl class="section note"><dt>Note</dt><dd>This device assumes that it can stretch the I2C clock, and it does so. The 200 us timeout that suffices for most I2C sensors used in nrfcxx is insufficient and will result in aborted transactions if separate register operations are initiated too close together. The I2C specification does not limit the duration of a stretched clock (SMBus specifies 35 ms), and the CCS811 data sheet does not provide a maximum stretch. 500 us TWI timeout appears to be adequate.</dd>
<dd>
The application infrastructure support described in GPIOTE::irq_handler must be provided when using <a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html" title="Interface to the ams CCS811 indoor air quality sensor.">ccs811</a>, and the following put in the main routine after the <a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html" title="Interface to the ams CCS811 indoor air quality sensor.">ccs811</a> instance has been constructed: <pre class="fragment">NVIC_EnableIRQ(GPIOTE_IRQn);
periph::GPIOTE::enable_sense();
</pre></dd></dl>
<p><a class="el" href="classnrfcxx_1_1lpm_1_1lpsm__capable.html#a34edb4653186ab238b357b77830b22e3" title="Make progress on an LPM collection.">lpm::lpsm_capable::lpsm_process()</a> for this sensor returns the following flags in addition to the diagnostic flags:</p><ul>
<li><a class="el" href="classnrfcxx_1_1lpm_1_1state__machine.html#a167b6e75d5e158c1c80b7a84a47ccef8" title="lpsm_capable::lpsm_process() flag bit when a new observation is available.">lpm::state_machine::PF_OBSERVATION</a></li>
<li><a class="el" href="classnrfcxx_1_1lpm_1_1state__machine.html#a9cc51a66d31775859b719b9f91ff796d" title="lpsm_capable::lpsm_process() flag bit when the machine has initiated a peripheral reset.">lpm::state_machine::PF_RESET</a></li>
<li><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#ade86615b05d390611f64db49cc7ac25f" title="Bit set in non-negative lpsm_process() result when a new observation identifies a CCS811 error in obs...">PF_CCS811_ERROR</a></li>
<li><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a9fd13b7be47031e3a639c2a6d10058a7" title="Bit set in non-negative lpsm_process() result when the sensor has started providing observations.">PF_REPORTING</a></li>
<li><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a831c2ade5276abb3d3c61ae45d00f1cd" title="Bit set in non-negative lpsm_process() result when the sensor has completed its conditioning period.">PF_CONDITIONED</a></li>
<li><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a64b5d51b7608bb5c247e1710d3483584" title="Bit set in non-negative lpsm_process() result when the machine updated the CCS811 baseline from retai...">PF_RESTORED</a></li>
<li><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a4fa883c87d18d08206483ab8779e43e4" title="Bit set in non-negative lpsm_process() result when the machine saved the BASELINE register to retaine...">PF_BASELINED</a> </li>
</ul>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a328932f17f7819e852473a047403474c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a328932f17f7819e852473a047403474c">&#9670;&nbsp;</a></span>status_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a328932f17f7819e852473a047403474c">nrfcxx::sensor::ccs811::status_type</a> =  uint16_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value for a valid CCS811 status. </p>
<p>The low byte corresponds to a value from the <code>STATUS</code> register. If <code>ST_ERROR</code> is cleared, the upper byte is zero, otherwise it is the value of the <code>ERROR_ID</code> register. </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a5c52ec083e05210e7aae9128f7fb56a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c52ec083e05210e7aae9128f7fb56a7">&#9670;&nbsp;</a></span>DRIVE_MODE_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a5c52ec083e05210e7aae9128f7fb56a7">nrfcxx::sensor::ccs811::DRIVE_MODE_e</a> : uint8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allowed drive modes for the <code>MEAS_MODE</code> register. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5c52ec083e05210e7aae9128f7fb56a7a054f31ca389fe333cbc75f3420e2488d"></a>DM_IDLE&#160;</td><td class="fielddoc"><p>Idle mode, no measurements will be produced. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5c52ec083e05210e7aae9128f7fb56a7a5d76fa2607d5d62274a72f6f8f736aee"></a>DM_1_s&#160;</td><td class="fielddoc"><p>Constant power, measurements every second. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5c52ec083e05210e7aae9128f7fb56a7a68f623a3235867f067b64d3d66fd4a4c"></a>DM_10_s&#160;</td><td class="fielddoc"><p>Pulse mode, measurements every 10 seconds. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5c52ec083e05210e7aae9128f7fb56a7ac64888e0cd6290dd2ef84425a0d60b8a"></a>DM_60_s&#160;</td><td class="fielddoc"><p>Low-pulse model, measurements every 60 seconds. </p>
</td></tr>
</table>

</div>
</div>
<a id="a76d59b8bf72d0d68ab5276fcbf38f9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76d59b8bf72d0d68ab5276fcbf38f9e5">&#9670;&nbsp;</a></span>STATUS_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a76d59b8bf72d0d68ab5276fcbf38f9e5">nrfcxx::sensor::ccs811::STATUS_e</a> : uint16_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a76d59b8bf72d0d68ab5276fcbf38f9e5ac1923289b79d243733ed876ca3fc0b7d"></a>ST_ERROR&#160;</td><td class="fielddoc"><p>If set the sensor or I2C bus has produced an error. </p>
<p>Consult the upper byte of <a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a6eeb285bbffb06fb0a33c95c8f632504" title="Read the STATUS and, if necessary, ERROR_ID registers.">status()</a> for the cause. </p>
</td></tr>
<tr><td class="fieldname"><a id="a76d59b8bf72d0d68ab5276fcbf38f9e5ad46611ace5f1ff9c6c186e506bc3a0be"></a>ST_DATA_READY&#160;</td><td class="fielddoc"><p>If set new data is available in the ALG_RESULT_DATA register. </p>
</td></tr>
<tr><td class="fieldname"><a id="a76d59b8bf72d0d68ab5276fcbf38f9e5acca5882b928dd6ca3f202f773a731b63"></a>ST_APP_VALID&#160;</td><td class="fielddoc"><p>If set a valid application image is available in the sensor. </p>
</td></tr>
<tr><td class="fieldname"><a id="a76d59b8bf72d0d68ab5276fcbf38f9e5a0ad0b0c6ee5d30752c9eae026c7013d7"></a>ST_APP_VERIFY&#160;</td><td class="fielddoc"><p>(Boot mode only) Set indicates that a verify operation succeeded. </p>
</td></tr>
<tr><td class="fieldname"><a id="a76d59b8bf72d0d68ab5276fcbf38f9e5ae7be2ced9f8ac073c1af2d85f5803d09"></a>ST_APP_ERASE&#160;</td><td class="fielddoc"><p>(Boot mode only) Set indicates that an erase operation succeeded. </p>
</td></tr>
<tr><td class="fieldname"><a id="a76d59b8bf72d0d68ab5276fcbf38f9e5a09acca32310e531a341c0252aadf581e"></a>ST_FW_MODE&#160;</td><td class="fielddoc"><p>Clear indicates device is in boot mode; set indicates device is in application mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="a76d59b8bf72d0d68ab5276fcbf38f9e5a1cecdb6d3ca70ba46812d5d85ae4e876"></a>EI_WRITE_REG_INVALID&#160;</td><td class="fielddoc"><p>If set an I2C write was attempted to an unwritable register. </p>
</td></tr>
<tr><td class="fieldname"><a id="a76d59b8bf72d0d68ab5276fcbf38f9e5a3c0bddf70075b094a3054790474a1b63"></a>EI_READ_REG_INVALID&#160;</td><td class="fielddoc"><p>If set an I2C read was attempted from an unreadable register. </p>
</td></tr>
<tr><td class="fieldname"><a id="a76d59b8bf72d0d68ab5276fcbf38f9e5affc12dfa0d029294c0d7b195683b7c8b"></a>EI_MEASMODE_INVALID&#160;</td><td class="fielddoc"><p>If set an I2C write to <code>MEAS_MODE</code> provided an unacceptable value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a76d59b8bf72d0d68ab5276fcbf38f9e5a2dbdbd564c058e32d23d96da455ae878"></a>EI_MAX_RESISTANCE&#160;</td><td class="fielddoc"><p>If set a the sensor has reached the maximum range. </p>
</td></tr>
<tr><td class="fieldname"><a id="a76d59b8bf72d0d68ab5276fcbf38f9e5a095275eb1e5dff1e56d07ce488dae491"></a>EI_HEATER_FAULT&#160;</td><td class="fielddoc"><p>If set the heater supply current is out of range. </p>
</td></tr>
<tr><td class="fieldname"><a id="a76d59b8bf72d0d68ab5276fcbf38f9e5a79816f48cbf43a748e44d044dffb6ba0"></a>EI_HEATER_SUPPLY&#160;</td><td class="fielddoc"><p>If set the heater supply voltage is not correct. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af5484145a56678b870a60bed05a21c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5484145a56678b870a60bed05a21c7b">&#9670;&nbsp;</a></span>ccs811()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nrfcxx::sensor::ccs811::ccs811 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacenrfcxx.html#aec2e5281eceb50c80579cc72a0b42e76">notifier_type</a>&#160;</td>
          <td class="paramname"><em>setter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrfcxx_1_1sensor_1_1ccs811_1_1iface__config__type.html">iface_config_type</a> &amp;&#160;</td>
          <td class="paramname"><em>ifc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addr_sec</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instantiate the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">setter</td><td>the mechanism by which the LPM machine notifies the application that it needs to be serviced.</td></tr>
    <tr><td class="paramname">ifc</td><td>reference to an externally owned struct providing the resources required to communicate with the device.</td></tr>
    <tr><td class="paramname">addr_sec</td><td>true indicates that the secondary I2C address should be used instead of the primary I2C address. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8e0c8e0fa353445e814f954687b2e11a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e0c8e0fa353445e814f954687b2e11a">&#9670;&nbsp;</a></span>active_drive_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nrfcxx::sensor::ccs811::active_drive_mode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the drive mode from the active state. </p>
<p>This need not match the value from <a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a7450897e4d3f72b7e396659821bee3d7" title="Read the configured drive mode.">drive_mode()</a> if the sensor is not active.</p>
<dl class="section return"><dt>Returns</dt><dd>a value from <a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a5c52ec083e05210e7aae9128f7fb56a7">DRIVE_MODE_e</a> extracted from retained_state_type::meas_mode (matching the <code>MEAS_MODE</code> register), or a negative error code if the sensor is not active. </dd></dl>

</div>
</div>
<a id="a691cf861296b4b4c28caa87e77830111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a691cf861296b4b4c28caa87e77830111">&#9670;&nbsp;</a></span>baseline() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nrfcxx::sensor::ccs811::baseline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the current baseline value. </p>
<dl class="section return"><dt>Returns</dt><dd>the non-negative value of the baseline register, or a negative error code. </dd></dl>

</div>
</div>
<a id="a29beafd205c9811abb7434c3641c366d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29beafd205c9811abb7434c3641c366d">&#9670;&nbsp;</a></span>baseline() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nrfcxx::sensor::ccs811::baseline </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the baseline value. </p>
<dl class="section note"><dt>Note</dt><dd>After setting this the read-back value appears to be unchanged from the previous setting, whether written after readings start being produced (about 30 s), or after the conditioning period completes (20 min). </dd></dl>

</div>
</div>
<a id="a12d067b2d88fd9dba260392e94a81ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12d067b2d88fd9dba260392e94a81ba1">&#9670;&nbsp;</a></span>drive_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nrfcxx::sensor::ccs811::drive_mode </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the drive mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dm</td><td>a valid value from <a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a5c52ec083e05210e7aae9128f7fb56a7">DRIVE_MODE_e</a>. All other values are rejected.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous drive mode on success, or a negative error code. </dd></dl>

</div>
</div>
<a id="acdfa9a9ef1aa43839d80e58c7531f015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdfa9a9ef1aa43839d80e58c7531f015">&#9670;&nbsp;</a></span>encode_env()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t nrfcxx::sensor::ccs811::encode_env </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>temp_cCel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rh_pptt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert temperature and humidity to CCS811 <code>ENV_DATA</code> format. </p>
<dl class="section note"><dt>Note</dt><dd>The encoded values are rounded to the nearest half-unit since the CCS811 firmware ignores any finer variation. See <a class="el" href="structnrfcxx_1_1sensor_1_1ccs811_1_1threshold__s.html#a226e135d9a9ebfc2e393bc71dcaef3c6" title="Compare two encoded environmental values for closeness.">threshold_s::env_data_changed()</a> for change detection support.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">temp_cCel</td><td>a temperature reading in centi-Celsius.</td></tr>
    <tr><td class="paramname">rh_pptt</td><td>a relative humidity reading, in RH * 100.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a uint32_t that, when written to the <code>ENV_DATA</code> register records the corresponding environment values. </dd></dl>

</div>
</div>
<a id="a2ba800d3ca2dd87c1acae89ecfade4a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ba800d3ca2dd87c1acae89ecfade4a4">&#9670;&nbsp;</a></span>env_data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nrfcxx::sensor::ccs811::env_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the last written environment data setting. </p>
<dl class="section note"><dt>Note</dt><dd>This comes from the driver, as the register cannot be read from the CCS811. A value with all 1s set indicates that the driver has not set the register.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>as specified. </dd></dl>

</div>
</div>
<a id="a5cc6399ed678a752a86bba0af34e376a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cc6399ed678a752a86bba0af34e376a">&#9670;&nbsp;</a></span>env_data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nrfcxx::sensor::ccs811::env_data </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>enc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the environment data structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enc</td><td>the temperature and humidity encoded by <a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#acdfa9a9ef1aa43839d80e58c7531f015" title="Convert temperature and humidity to CCS811 ENV_DATA format.">encode_env()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-negative on success, or a negative error code. </dd></dl>

</div>
</div>
<a id="aa405dd673b6d303c973ba873b306ff70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa405dd673b6d303c973ba873b306ff70">&#9670;&nbsp;</a></span>fill_system_beacon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nrfcxx::sensor::ccs811::fill_system_beacon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfcxx_1_1sensor_1_1ccs811_1_1system__beacon__type.html">system_beacon_type</a> &amp;&#160;</td>
          <td class="paramname"><em>fr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the contents of a system beacon frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">fr</td><td>where the frame information should be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero on success, or a negative error code. </dd></dl>

</div>
</div>
<a id="ab7538494795381638f243340a516046e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7538494795381638f243340a516046e">&#9670;&nbsp;</a></span>id_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nrfcxx::sensor::ccs811::id_version </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfcxx_1_1sensor_1_1ccs811_1_1version__s.html">version_s</a> &amp;&#160;</td>
          <td class="paramname"><em>vid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the device hardware and firmware identity and version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">vid</td><td>where the version information will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-negative on success, or a negative error code. </dd></dl>

</div>
</div>
<a id="aa1cd7232128d9b7d081ed3ec537a3fd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1cd7232128d9b7d081ed3ec537a3fd5">&#9670;&nbsp;</a></span>observation_beacon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnrfcxx_1_1sensor_1_1ccs811_1_1observation__beacon__type.html">observation_beacon_type</a> nrfcxx::sensor::ccs811::observation_beacon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate and return an observation beacon structure from the current state. </p>
<dl class="section note"><dt>Note</dt><dd>It is the caller's responsibility to ensure that the state of the observation is valid by revewing the content of <a class="el" href="structnrfcxx_1_1sensor_1_1ccs811_1_1observation__beacon__type.html#ab9295fdd588516b6f443c7f48e141cba" title="Untransmitted content to simplify change detection.">observation_beacon_type::status</a>. </dd></dl>

</div>
</div>
<a id="a97f043ae708d1f1b855dd78309916c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97f043ae708d1f1b855dd78309916c0e">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nrfcxx::sensor::ccs811::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Toggle the RESETn line to reset the sensor. </p>
<dl class="section return"><dt>Returns</dt><dd>a non-negative value is the delay before the the sensor may be accessed, in uptime ticks. A negative value indicates failure to reset. </dd></dl>

</div>
</div>
<a id="a001fc07569d65ddf10757ae9a455e014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a001fc07569d65ddf10757ae9a455e014">&#9670;&nbsp;</a></span>restore_from_persisted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nrfcxx::sensor::ccs811::restore_from_persisted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnrfcxx_1_1sensor_1_1ccs811_1_1persisted__state__type.html">persisted_state_type</a> &amp;&#160;</td>
          <td class="paramname"><em>ps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the retained state with information from persisted state. </p>
<p>If <code>ps</code> has a non-zero baseline for the drive mode configured in retained_state_type::meas_mode and <a class="el" href="structnrfcxx_1_1sensor_1_1ccs811_1_1retained__state__type.html#a1959def48bc8bafd929a4980fa45f645ac9c2f76bb926e597abb4661837eb3e60" title="Flag set when baseline has been set to a valid value.">retained_state_type::FL_BASELINED</a> is not currently set then <a class="el" href="structnrfcxx_1_1sensor_1_1ccs811_1_1retained__state__type.html#a4860bf093d0802fac5ce045a117782ca" title="The most recently validated BASELINE register value.">retained_state_type::baseline</a> is set from the persisted state and <a class="el" href="structnrfcxx_1_1sensor_1_1ccs811_1_1retained__state__type.html#a1959def48bc8bafd929a4980fa45f645ac9c2f76bb926e597abb4661837eb3e60" title="Flag set when baseline has been set to a valid value.">retained_state_type::FL_BASELINED</a> is set.</p>
<p>This function should be invoked on receipt of <a class="el" href="classnrfcxx_1_1lpm_1_1state__machine.html#ae2b5f47cf3c62345f3b20ecfd2c77601" title="lpsm_capable::lpsm_process() flag bit when the machine is ready to provide observations.">lpm::state_machine::PF_STARTED</a> so that when <a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a831c2ade5276abb3d3c61ae45d00f1cd" title="Bit set in non-negative lpsm_process() result when the sensor has completed its conditioning period.">PF_CONDITIONED</a> occurs the LPM machine will restore the <code>BASELINE</code> register in the CCS811.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ps</td><td>the persisted state that may contain a relevant baseline.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero on successful update, or a negative error code. </dd></dl>

</div>
</div>
<a id="aa384e91652ccc6da2a02c8005c3e8db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa384e91652ccc6da2a02c8005c3e8db9">&#9670;&nbsp;</a></span>retain_baseline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nrfcxx::sensor::ccs811::retain_baseline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record the current baseline in retained state. </p>
<p>This may be invoked under external control to capture the baseline when it is known the sensor is in clean air.</p>
<p>The invocation fails if the CCS811 has not completed the conditioning period, or does not have an <a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a064fb16441c15508de7cb34b6ea0d675">observation</a> from which the baseline can be taken.</p>
<dl class="section return"><dt>Returns</dt><dd>a non-negative baseline on success, or a negative error code.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#abfafdc80c28a524648a4525a40700237" title="Update a persisted state with information from retained state.">update_persisted()</a> </dd></dl>

</div>
</div>
<a id="aa16e35425088671cc0f4645a9a997bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16e35425088671cc0f4645a9a997bce">&#9670;&nbsp;</a></span>scoped_enable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnrfcxx_1_1sensor_1_1ccs811_1_1scoped__enabler.html">scoped_enabler</a> nrfcxx::sensor::ccs811::scoped_enable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct and return an RAII object that supports TWI interaction. </p>
<p>Use this within a scope to assert <code>WAKEn</code> and enable the associated TWI peripheral.</p>
<p>Success of the enable can be assessed from <a class="el" href="classnrfcxx_1_1sensor_1_1ccs811_1_1scoped__enabler.html#a97c62224151cce1b1bd28e432d115ec9" title="Return the result of invoking periph::TWI::enable() in the constructor.">scoped_enabler::result()</a> or treating the enabler as a bool: </p><pre class="fragment">if (auto enabler = sensor.scoped_enable()) {
  // invoke methods that interact with sensor
  rc = twi...;
} else {
  // handle interface failure
  rc = enabler.result();
}
</pre><dl class="section note"><dt>Note</dt><dd>Public methods on this class always ensure TWI operations occur within an enabled scope. </dd></dl>

</div>
</div>
<a id="ab7141846e808f392b1800b1b027a5a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7141846e808f392b1800b1b027a5a83">&#9670;&nbsp;</a></span>state_setup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void nrfcxx::sensor::ccs811::state_setup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnrfcxx_1_1systemState_1_1state__type.html">systemState::state_type</a> &amp;&#160;</td>
          <td class="paramname"><em>ss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_reset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retained</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to maintain CCS811 state across resets. </p>
<p>This must be invoked from the application's <a class="el" href="classnrfcxx_1_1systemState.html" title="A class supporting watchdog configuration and cross-reset retention of state.">systemState</a> <a class="el" href="">app_handler</a> to ensure <a class="el" href="">telemetry state</a> is properly managed. </p>

</div>
</div>
<a id="a6eeb285bbffb06fb0a33c95c8f632504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eeb285bbffb06fb0a33c95c8f632504">&#9670;&nbsp;</a></span>status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nrfcxx::sensor::ccs811::status </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the <code>STATUS</code> and, if necessary, <code>ERROR_ID</code> registers. </p>
<p>If successful, the low 8 bits of the return value correspond to the value of the STATUS register. If ST_ERROR is set then bits 8..15 of the returned value have the corresponding ERROR_ID register value.</p>
<dl class="section note"><dt>Note</dt><dd>reading ERROR_ID clears that register, so pay attention to the ST_ERROR bit on what you get back: this is the only chance you'll have to see it.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a non-negative value as documented for <a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a328932f17f7819e852473a047403474c">status_type</a>, or a negative error code. </dd></dl>

</div>
</div>
<a id="abfafdc80c28a524648a4525a40700237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfafdc80c28a524648a4525a40700237">&#9670;&nbsp;</a></span>update_persisted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nrfcxx::sensor::ccs811::update_persisted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfcxx_1_1sensor_1_1ccs811_1_1persisted__state__type.html">persisted_state_type</a> &amp;&#160;</td>
          <td class="paramname"><em>ps</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a persisted state with information from retained state. </p>
<p>If <a class="el" href="structnrfcxx_1_1sensor_1_1ccs811_1_1retained__state__type.html#a1959def48bc8bafd929a4980fa45f645ac9c2f76bb926e597abb4661837eb3e60" title="Flag set when baseline has been set to a valid value.">retained_state_type::FL_BASELINED</a> is set then the baseline for the current mode is copied into the appropriate section of <code>ps</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This should be invoked by the application whenever <a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a4fa883c87d18d08206483ab8779e43e4" title="Bit set in non-negative lpsm_process() result when the machine saved the BASELINE register to retaine...">PF_BASELINED</a> is produced, or when save_baseline() is executed under application control. It is the application's responsibility to persist the updated structure.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ps</td><td>where the persisted state should be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero on successful update, or a negative error code. </dd></dl>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a939ed1844b895a4b65df1ec31a2ebd97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a939ed1844b895a4b65df1ec31a2ebd97">&#9670;&nbsp;</a></span>CONDITIONING_DELAY_utt</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned int nrfcxx::sensor::ccs811::CONDITIONING_DELAY_utt = 20U * 60U * clock::uptime::Frequency_Hz</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Duration of the conditioning period, in uptime ticks. </p>
<p>This is the period after initial power-up or measurement start during which the sensor is warming up. The <code>BASELINE</code> register should not be written until after this period elapses.</p>
<p>See <a href="https://ams.com/ccs811#tab/documents">AN370: Baseline Save and Restore</a>. </p>

</div>
</div>
<a id="a4fa883c87d18d08206483ab8779e43e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fa883c87d18d08206483ab8779e43e4">&#9670;&nbsp;</a></span>PF_BASELINED</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto nrfcxx::sensor::ccs811::PF_BASELINED = <a class="el" href="classnrfcxx_1_1lpm_1_1state__machine.html#ac318c7a59857181f6bc9a9aae7f0d4ad">lpm::state_machine::PF_APP_BASE</a> &lt;&lt; 3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bit set in non-negative <a class="el" href="classnrfcxx_1_1lpm_1_1lpsm__capable.html#a34edb4653186ab238b357b77830b22e3" title="Make progress on an LPM collection.">lpsm_process()</a> result when the machine saved the <code>BASELINE</code> register to retained state. </p>
<p>On receipt of this applications should use <a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#abfafdc80c28a524648a4525a40700237" title="Update a persisted state with information from retained state.">update_persisted()</a> to update the non-volatile persisted state in case the volatile retained state is lost due to a power-cycle or uncontrolled reset. </p>

</div>
</div>
<a id="a9fd13b7be47031e3a639c2a6d10058a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd13b7be47031e3a639c2a6d10058a7">&#9670;&nbsp;</a></span>PF_REPORTING</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto nrfcxx::sensor::ccs811::PF_REPORTING = <a class="el" href="classnrfcxx_1_1lpm_1_1state__machine.html#ac318c7a59857181f6bc9a9aae7f0d4ad">lpm::state_machine::PF_APP_BASE</a> &lt;&lt; 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bit set in non-negative <a class="el" href="classnrfcxx_1_1lpm_1_1lpsm__capable.html#a34edb4653186ab238b357b77830b22e3" title="Make progress on an LPM collection.">lpsm_process()</a> result when the sensor has started providing observations. </p>
<p>This is set coincident with the first occurrence of <a class="el" href="classnrfcxx_1_1lpm_1_1state__machine.html#a167b6e75d5e158c1c80b7a84a47ccef8" title="lpsm_capable::lpsm_process() flag bit when a new observation is available.">lpm::state_machine::PF_OBSERVATION</a> where STATUS_e::ST_DATA_READY is set. </p>

</div>
</div>
<a id="a64b5d51b7608bb5c247e1710d3483584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64b5d51b7608bb5c247e1710d3483584">&#9670;&nbsp;</a></span>PF_RESTORED</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto nrfcxx::sensor::ccs811::PF_RESTORED = <a class="el" href="classnrfcxx_1_1lpm_1_1state__machine.html#ac318c7a59857181f6bc9a9aae7f0d4ad">lpm::state_machine::PF_APP_BASE</a> &lt;&lt; 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bit set in non-negative <a class="el" href="classnrfcxx_1_1lpm_1_1lpsm__capable.html#a34edb4653186ab238b357b77830b22e3" title="Make progress on an LPM collection.">lpsm_process()</a> result when the machine updated the CCS811 baseline from retained state. </p>
<p>This will occur in conjunction with <a class="el" href="classnrfcxx_1_1sensor_1_1ccs811.html#a831c2ade5276abb3d3c61ae45d00f1cd" title="Bit set in non-negative lpsm_process() result when the sensor has completed its conditioning period.">PF_CONDITIONED</a> when a baseline is available. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>nrfcxx/sensor/<a class="el" href="ccs811_8hpp_source.html">ccs811.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
