<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nrfcxx: nrfcxx/newlib/system.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">nrfcxx
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
   <div id="projectbrief">C++-17 Framework for Nordic nRF5 Devices</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_427bf8e43458ad25d918268f234eae15.html">nrfcxx</a></li><li class="navelem"><a class="el" href="dir_078beaeb20171fe4ca53c2afe38d3e86.html">newlib</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">system.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>NRFCXX system enhancements to newlib.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;unistd.h&gt;</code><br />
</div>
<p><a href="system_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a766098993afb723d1c105021ed54c18a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="system_8h.html#a766098993afb723d1c105021ed54c18a">_nrfcxx_sbrk_fatal</a> (ptrdiff_t increment)</td></tr>
<tr class="memdesc:a766098993afb723d1c105021ed54c18a"><td class="mdescLeft">&#160;</td><td class="mdescRight">An sbrk() implementation that rejects any attempt to allocate memory dynamically.  <a href="#a766098993afb723d1c105021ed54c18a">More...</a><br /></td></tr>
<tr class="separator:a766098993afb723d1c105021ed54c18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56f4233a41b5e0b2aa48a7afc3bb7f1c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="system_8h.html#a56f4233a41b5e0b2aa48a7afc3bb7f1c">_nrfcxx_sbrk_heap</a> (ptrdiff_t increment)</td></tr>
<tr class="memdesc:a56f4233a41b5e0b2aa48a7afc3bb7f1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">An sbrk() implementation that depends on a fixed heap allocated within the standard startup infrastructure.  <a href="#a56f4233a41b5e0b2aa48a7afc3bb7f1c">More...</a><br /></td></tr>
<tr class="separator:a56f4233a41b5e0b2aa48a7afc3bb7f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2353bb637d4e2617b4c4c42b6c8da375"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="system_8h.html#a2353bb637d4e2617b4c4c42b6c8da375">_nrfcxx_sbrk_fixedstack</a> (ptrdiff_t increment)</td></tr>
<tr class="memdesc:a2353bb637d4e2617b4c4c42b6c8da375"><td class="mdescLeft">&#160;</td><td class="mdescRight">An sbrk() implementation that allows heap (growing up) to grow to the bottom of a reserved stack region.  <a href="#a2353bb637d4e2617b4c4c42b6c8da375">More...</a><br /></td></tr>
<tr class="separator:a2353bb637d4e2617b4c4c42b6c8da375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6eb8a8f6ef52209769424f060227baa"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="system_8h.html#ac6eb8a8f6ef52209769424f060227baa">_nrfcxx_sbrk_dynstack</a> (ptrdiff_t increment)</td></tr>
<tr class="memdesc:ac6eb8a8f6ef52209769424f060227baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">An sbrk() implementation that allows heap (growing up) and stack (growing down) to share a region of memory.  <a href="#ac6eb8a8f6ef52209769424f060227baa">More...</a><br /></td></tr>
<tr class="separator:ac6eb8a8f6ef52209769424f060227baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f14060b45ff8811a54f8a1ce8c86be"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="system_8h.html#a70f14060b45ff8811a54f8a1ce8c86be">_nrfcxx_sbrk_unlimitedstack</a> (ptrdiff_t increment)</td></tr>
<tr class="memdesc:a70f14060b45ff8811a54f8a1ce8c86be"><td class="mdescLeft">&#160;</td><td class="mdescRight">An sbrk() implementation that allows heap (growing up) and stack (growing down) to share a region of memory, with a minimum size reserved for the stack but allowing for the stack to grow below that point.  <a href="#a70f14060b45ff8811a54f8a1ce8c86be">More...</a><br /></td></tr>
<tr class="separator:a70f14060b45ff8811a54f8a1ce8c86be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e846ae6eacaa1873989f1d799fa104c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="system_8h.html#a7e846ae6eacaa1873989f1d799fa104c">_sbrk</a> (intptr_t increment)</td></tr>
<tr class="memdesc:a7e846ae6eacaa1873989f1d799fa104c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The system function used to allocate memory for use by libc heap memory management.  <a href="#a7e846ae6eacaa1873989f1d799fa104c">More...</a><br /></td></tr>
<tr class="separator:a7e846ae6eacaa1873989f1d799fa104c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d68d4a865cb749a3cade236a041526d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="system_8h.html#a1d68d4a865cb749a3cade236a041526d">_nrfcxx_sbrk_error</a> (void *brk, ptrdiff_t current, ptrdiff_t increment)</td></tr>
<tr class="memdesc:a1d68d4a865cb749a3cade236a041526d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is invoked whenever <a class="el" href="system_8h.html#a7e846ae6eacaa1873989f1d799fa104c" title="The system function used to allocate memory for use by libc heap memory management.">_sbrk()</a> runs out of memory.  <a href="#a1d68d4a865cb749a3cade236a041526d">More...</a><br /></td></tr>
<tr class="separator:a1d68d4a865cb749a3cade236a041526d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680796870e273b96208fe4016109665f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="system_8h.html#a680796870e273b96208fe4016109665f">_nrfcxx_cstdio_allowed</a> (bool allowed)</td></tr>
<tr class="memdesc:a680796870e273b96208fe4016109665f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function used to control whether the automatic enabling of UART to support stdio operations is supported.  <a href="#a680796870e273b96208fe4016109665f">More...</a><br /></td></tr>
<tr class="separator:a680796870e273b96208fe4016109665f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9472b9eca011b8e7177837e0f923e7eb"><td class="memItemLeft" align="right" valign="top"><a id="a9472b9eca011b8e7177837e0f923e7eb"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="system_8h.html#a9472b9eca011b8e7177837e0f923e7eb">_nrfcxx_heap_used</a> (void)</td></tr>
<tr class="memdesc:a9472b9eca011b8e7177837e0f923e7eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the amount of heap memory currently in use within the system, in bytes. <br /></td></tr>
<tr class="separator:a9472b9eca011b8e7177837e0f923e7eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>NRFCXX system enhancements to newlib. </p>
<p>This file declares functions that support the newlib nosys replacement used by default in nrfcxx.</p>
<dl class="section note"><dt>Note</dt><dd>Several parts of newlib require support for allocation from the heap. If the stdio infrastructure is referenced normally, roughly 1468 bytes is allocated for state maintenance. If setvbuf(3) is used to disable buffering on stdio, this is reduced to about 436 bytes. In any case, selecting <a class="el" href="system_8h.html#a766098993afb723d1c105021ed54c18a" title="An sbrk() implementation that rejects any attempt to allocate memory dynamically.">_nrfcxx_sbrk_fatal()</a> will cause failures if some newlib functions are invoked, and reducing the default heap allocation in startup_CMx.S is risky. </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a680796870e273b96208fe4016109665f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a680796870e273b96208fe4016109665f">&#9670;&nbsp;</a></span>_nrfcxx_cstdio_allowed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool _nrfcxx_cstdio_allowed </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function used to control whether the automatic enabling of UART to support stdio operations is supported. </p>
<p>For convenience during development this feature is enabled by default, but having a UART running and active can complicate power and critical timing measurements. Invoking this function <em>prior to any cstdio operations</em> will inhibit starting the UART and cause all primitive I/O operations to return as though they did something.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allowed</td><td>if <code>false</code> will prevent any subsequent cstdio operations from enabling the UART.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff the UART had already been automatically enabled in support of cstdio operations. </dd></dl>

</div>
</div>
<a id="ac6eb8a8f6ef52209769424f060227baa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6eb8a8f6ef52209769424f060227baa">&#9670;&nbsp;</a></span>_nrfcxx_sbrk_dynstack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* _nrfcxx_sbrk_dynstack </td>
          <td>(</td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>increment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An sbrk() implementation that allows heap (growing up) and stack (growing down) to share a region of memory. </p>
<p>An error is indicated if the new break point would encroach into the current stack space.</p>
<dl class="section note"><dt>Note</dt><dd>Like _nrfcxx_sbrk_unlimited(), but eliminating the minimum reserved stack. Not sure why this would be worth doing, but for completeness.... </dd></dl>

</div>
</div>
<a id="a1d68d4a865cb749a3cade236a041526d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d68d4a865cb749a3cade236a041526d">&#9670;&nbsp;</a></span>_nrfcxx_sbrk_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* _nrfcxx_sbrk_error </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>brk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>increment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is invoked whenever <a class="el" href="system_8h.html#a7e846ae6eacaa1873989f1d799fa104c" title="The system function used to allocate memory for use by libc heap memory management.">_sbrk()</a> runs out of memory. </p>
<p><code>libnrfcxx.a</code> provides a weak definition that invokes <a class="el" href="namespacenrfcxx.html#a48a72359e3e4d7aaee4b9ea0d6c6c015" title="Record a critical system failure and reset the system.">nrfcxx::failsafe</a> with <a class="el" href="namespacenrfcxx.html#a0c34d4f67cc579f14cc37908a6045c7ea9cbb164e6a6eeacd8d8a1ba79fb6528c" title="Allocated too much from system heap.">nrfcxx::FailSafeCode::HEAP_OVERRUN</a>. The application may provide an alternative implementation that is more diagnostic or that returns the responsibility of handling out-of-memory to the application (i.e. requires the application to check allocation return values).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">brk</td><td>the current program break</td></tr>
    <tr><td class="paramname">current</td><td>total number of bytes allocated by previous successful invocations of <a class="el" href="system_8h.html#a7e846ae6eacaa1873989f1d799fa104c" title="The system function used to allocate memory for use by libc heap memory management.">_sbrk()</a> (i.e., allocated bytes preceding <code>brk</code>)</td></tr>
    <tr><td class="paramname">increment</td><td>the number of bytes in the request that <a class="el" href="system_8h.html#a7e846ae6eacaa1873989f1d799fa104c" title="The system function used to allocate memory for use by libc heap memory management.">_sbrk()</a> cannot satisfy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function need not return. An implementation that does return must set <code>errno</code> to <code>ENOMEM</code> and return <code>(void*)-1</code>. </dd></dl>

</div>
</div>
<a id="a766098993afb723d1c105021ed54c18a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a766098993afb723d1c105021ed54c18a">&#9670;&nbsp;</a></span>_nrfcxx_sbrk_fatal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* _nrfcxx_sbrk_fatal </td>
          <td>(</td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>increment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An sbrk() implementation that rejects any attempt to allocate memory dynamically. </p>
<p>This is not quite equivalent to <a class="el" href="system_8h.html#a56f4233a41b5e0b2aa48a7afc3bb7f1c" title="An sbrk() implementation that depends on a fixed heap allocated within the standard startup infrastru...">_nrfcxx_sbrk_heap()</a> with a zero-sized heap, as simply invoking <a class="el" href="system_8h.html#a7e846ae6eacaa1873989f1d799fa104c" title="The system function used to allocate memory for use by libc heap memory management.">_sbrk()</a> will result in the failure even if the requested increment was zero.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="system_8h.html#a9472b9eca011b8e7177837e0f923e7eb" title="Return the amount of heap memory currently in use within the system, in bytes.">_nrfcxx_heap_used()</a> invokes _sbrk with a zero increment. So does newlib prior to allocating for stdio support. </dd></dl>

</div>
</div>
<a id="a2353bb637d4e2617b4c4c42b6c8da375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2353bb637d4e2617b4c4c42b6c8da375">&#9670;&nbsp;</a></span>_nrfcxx_sbrk_fixedstack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* _nrfcxx_sbrk_fixedstack </td>
          <td>(</td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>increment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An sbrk() implementation that allows heap (growing up) to grow to the bottom of a reserved stack region. </p>
<p>An error is indicated if the new program break would encroach into the reserved stack space. There is no check against the current stack pointer.</p>
<dl class="section note"><dt>Note</dt><dd>This policy is preferred to <a class="el" href="system_8h.html#a70f14060b45ff8811a54f8a1ce8c86be" title="An sbrk() implementation that allows heap (growing up) and stack (growing down) to share a region of ...">_nrfcxx_sbrk_unlimitedstack()</a> when code may be executing in tasks where the stack frame is in previously allocated memory. </dd></dl>

</div>
</div>
<a id="a56f4233a41b5e0b2aa48a7afc3bb7f1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56f4233a41b5e0b2aa48a7afc3bb7f1c">&#9670;&nbsp;</a></span>_nrfcxx_sbrk_heap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* _nrfcxx_sbrk_heap </td>
          <td>(</td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>increment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An sbrk() implementation that depends on a fixed heap allocated within the standard startup infrastructure. </p>
<p>An error is indicated if the reserved heap size would be exceeded. There is no check against the current stack pointer. </p>

</div>
</div>
<a id="a70f14060b45ff8811a54f8a1ce8c86be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f14060b45ff8811a54f8a1ce8c86be">&#9670;&nbsp;</a></span>_nrfcxx_sbrk_unlimitedstack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* _nrfcxx_sbrk_unlimitedstack </td>
          <td>(</td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>increment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An sbrk() implementation that allows heap (growing up) and stack (growing down) to share a region of memory, with a minimum size reserved for the stack but allowing for the stack to grow below that point. </p>
<p>An error is indicated if the new break point would encroach into the reserved stack space or the currently used stack space. </p>

</div>
</div>
<a id="a7e846ae6eacaa1873989f1d799fa104c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e846ae6eacaa1873989f1d799fa104c">&#9670;&nbsp;</a></span>_sbrk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* _sbrk </td>
          <td>(</td>
          <td class="paramtype">intptr_t&#160;</td>
          <td class="paramname"><em>increment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The system function used to allocate memory for use by libc heap memory management. </p>
<p>By default this symbol is a weak alias to <a class="el" href="system_8h.html#a70f14060b45ff8811a54f8a1ce8c86be" title="An sbrk() implementation that allows heap (growing up) and stack (growing down) to share a region of ...">_nrfcxx_sbrk_unlimitedstack()</a>. This matches the nosys behavior of newlib. To select another policy you must provide a non-weak alias to one of the other policies or your own implementation. Alternative implementations include:</p><ul>
<li><a class="el" href="system_8h.html#a766098993afb723d1c105021ed54c18a" title="An sbrk() implementation that rejects any attempt to allocate memory dynamically.">_nrfcxx_sbrk_fatal()</a></li>
<li><a class="el" href="system_8h.html#a56f4233a41b5e0b2aa48a7afc3bb7f1c" title="An sbrk() implementation that depends on a fixed heap allocated within the standard startup infrastru...">_nrfcxx_sbrk_heap()</a></li>
<li><a class="el" href="system_8h.html#a2353bb637d4e2617b4c4c42b6c8da375" title="An sbrk() implementation that allows heap (growing up) to grow to the bottom of a reserved stack regi...">_nrfcxx_sbrk_fixedstack()</a></li>
<li><a class="el" href="system_8h.html#ac6eb8a8f6ef52209769424f060227baa" title="An sbrk() implementation that allows heap (growing up) and stack (growing down) to share a region of ...">_nrfcxx_sbrk_dynstack()</a></li>
<li><a class="el" href="system_8h.html#a70f14060b45ff8811a54f8a1ce8c86be" title="An sbrk() implementation that allows heap (growing up) and stack (growing down) to share a region of ...">_nrfcxx_sbrk_unlimitedstack()</a></li>
</ul>
<p>You can do this in the application main file with: </p><pre class="fragment">extern "C" {
void* _sbrk_for_app (ptrdiff_t increment)
{
  return _nrfcxx_sbrk_heap(increment);
}
void* _sbrk (ptrdiff_t increment) __attribute__((__alias__("_sbrk_for_app")));
}
</pre><dl class="section note"><dt>Note</dt><dd>As of GCC 4 the alias must be defined in the same translation unit, hence the need for a local definition that wraps the provided function.</dd></dl>
<p>The reserved system stack space is 3 KiBy, which is sufficient for use with standard newlib operations. The application can increase this by declaring objects that will force that space to be expanded, as with: </p><pre class="fragment">__attribute__((__section__(".heap.extension")))
volatile uint32_t extend_by_512_words[512];
</pre><dl class="section note"><dt>Note</dt><dd>All NRFCXX policies invoke <a class="el" href="system_8h.html#a1d68d4a865cb749a3cade236a041526d" title="This function is invoked whenever _sbrk() runs out of memory.">_nrfcxx_sbrk_error()</a> if allocation fails, allowing an application to control response to the failure.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">increment</td><td>the number of bytes of additional memory that libc needs in order to perform additional allocations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new end-of-memory, or <code>(void*)-1</code> if no allocation can be performed.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="system_8h.html#a9472b9eca011b8e7177837e0f923e7eb" title="Return the amount of heap memory currently in use within the system, in bytes.">_nrfcxx_heap_used</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
