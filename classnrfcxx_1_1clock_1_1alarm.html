<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nrfcxx: nrfcxx::clock::alarm Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">nrfcxx
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
   <div id="projectbrief">C++-17 Framework for Nordic nRF5 Devices</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenrfcxx.html">nrfcxx</a></li><li class="navelem"><a class="el" href="namespacenrfcxx_1_1clock.html">clock</a></li><li class="navelem"><a class="el" href="classnrfcxx_1_1clock_1_1alarm.html">alarm</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Data Fields</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">nrfcxx::clock::alarm Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class supporting an alarm with custom callback and repeatability.  
 <a href="classnrfcxx_1_1clock_1_1alarm.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="clock_8hpp_source.html">nrfcxx/clock.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a89c77d2d2f84abc5e8ab32db6259a187"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a89c77d2d2f84abc5e8ab32db6259a187">state_type</a> { <br />
&#160;&#160;<a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a89c77d2d2f84abc5e8ab32db6259a187a8d87ec06648b45a8ad33dd20d8a0799c">ST_unscheduled</a>, 
<a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a89c77d2d2f84abc5e8ab32db6259a187a1198849a88d6502334d22bb14a7a1808">ST_scheduled</a>, 
<a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a89c77d2d2f84abc5e8ab32db6259a187a84a42cd6956c6afa4d66f587fc3e15b1">ST_ready</a>, 
<a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a89c77d2d2f84abc5e8ab32db6259a187aa7328d628b729f989325e88fa517166c">ST_in_callback</a>, 
<br />
&#160;&#160;<a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a89c77d2d2f84abc5e8ab32db6259a187aa488090673e99ddc10de42f1f64895cb">ST_cancelled</a>
<br />
 }</td></tr>
<tr class="memdesc:a89c77d2d2f84abc5e8ab32db6259a187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constants identifying the alarm state.  <a href="classnrfcxx_1_1clock_1_1alarm.html#a89c77d2d2f84abc5e8ab32db6259a187">More...</a><br /></td></tr>
<tr class="separator:a89c77d2d2f84abc5e8ab32db6259a187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6ef4dd075de721982d104c1a3c2573"><td class="memItemLeft" align="right" valign="top"><a id="a5a6ef4dd075de721982d104c1a3c2573"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a5a6ef4dd075de721982d104c1a3c2573">mutex_type</a> = <a class="el" href="classnrfcxx_1_1clock_1_1uptime.html#a3fe25822cf66b20d6d8cff6773c4d833">uptime::mutex_type</a></td></tr>
<tr class="memdesc:a5a6ef4dd075de721982d104c1a3c2573"><td class="mdescLeft">&#160;</td><td class="mdescRight">An RAII type for mutex access blocking changes to alarm state. <br /></td></tr>
<tr class="separator:a5a6ef4dd075de721982d104c1a3c2573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0dd22ca5daee1992a3303facc84efb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#afb0dd22ca5daee1992a3303facc84efb">callback_type</a> = std::function&lt; bool(<a class="el" href="classnrfcxx_1_1clock_1_1alarm.html">alarm</a> &amp;<a class="el" href="classnrfcxx_1_1clock_1_1alarm.html">alarm</a>)&gt;</td></tr>
<tr class="memdesc:afb0dd22ca5daee1992a3303facc84efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The signature of an alarm callback function.  <a href="#afb0dd22ca5daee1992a3303facc84efb">More...</a><br /></td></tr>
<tr class="separator:afb0dd22ca5daee1992a3303facc84efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9f98b48056733c3b1da5ed109fc8ba32"><td class="memItemLeft" align="right" valign="top"><a id="a9f98b48056733c3b1da5ed109fc8ba32"></a>
<a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a89c77d2d2f84abc5e8ab32db6259a187">state_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a9f98b48056733c3b1da5ed109fc8ba32">state</a> () const</td></tr>
<tr class="memdesc:a9f98b48056733c3b1da5ed109fc8ba32"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current state of the alarm. <br /></td></tr>
<tr class="separator:a9f98b48056733c3b1da5ed109fc8ba32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f942833f0b77cc3a41a69cc92f6416b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a0f942833f0b77cc3a41a69cc92f6416b">active</a> () const</td></tr>
<tr class="memdesc:a0f942833f0b77cc3a41a69cc92f6416b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the alarm state is one of <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a89c77d2d2f84abc5e8ab32db6259a187a1198849a88d6502334d22bb14a7a1808" title="Alarm is in the queue to execute at some point in the future.">ST_scheduled</a>, <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a89c77d2d2f84abc5e8ab32db6259a187a84a42cd6956c6afa4d66f587fc3e15b1" title="Alarm deadline has been reached and the callback will soon be invoked.">ST_ready</a>, or <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a89c77d2d2f84abc5e8ab32db6259a187aa7328d628b729f989325e88fa517166c" title="The callback is being invoked.">ST_in_callback</a>.  <a href="#a0f942833f0b77cc3a41a69cc92f6416b">More...</a><br /></td></tr>
<tr class="separator:a0f942833f0b77cc3a41a69cc92f6416b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affaf8618bc1a66380dff7119a6d627ba"><td class="memItemLeft" align="right" valign="top"><a id="affaf8618bc1a66380dff7119a6d627ba"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>alarm</b> (const <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html">alarm</a> &amp;)=delete</td></tr>
<tr class="separator:affaf8618bc1a66380dff7119a6d627ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a7dea48ab85cfd9020017a118e847e"><td class="memItemLeft" align="right" valign="top"><a id="ae7a7dea48ab85cfd9020017a118e847e"></a>
<a class="el" href="classnrfcxx_1_1clock_1_1alarm.html">alarm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html">alarm</a> &amp;)=delete</td></tr>
<tr class="separator:ae7a7dea48ab85cfd9020017a118e847e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac024ca4586e1e8e5e1f4b5a3b644f41f"><td class="memItemLeft" align="right" valign="top"><a id="ac024ca4586e1e8e5e1f4b5a3b644f41f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>alarm</b> (<a class="el" href="classnrfcxx_1_1clock_1_1alarm.html">alarm</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:ac024ca4586e1e8e5e1f4b5a3b644f41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fdca1a7f1f315d18d542bfb5a2bb6c9"><td class="memItemLeft" align="right" valign="top"><a id="a9fdca1a7f1f315d18d542bfb5a2bb6c9"></a>
<a class="el" href="classnrfcxx_1_1clock_1_1alarm.html">alarm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classnrfcxx_1_1clock_1_1alarm.html">alarm</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a9fdca1a7f1f315d18d542bfb5a2bb6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963866c44cad49de114b0adc455255f9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a963866c44cad49de114b0adc455255f9">alarm</a> (<a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#afb0dd22ca5daee1992a3303facc84efb">callback_type</a> callback, unsigned int <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a794a1ef6c56a23fd1441718931556761">interval</a>=0, void *md=0)</td></tr>
<tr class="memdesc:a963866c44cad49de114b0adc455255f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard alarm constructor.  <a href="#a963866c44cad49de114b0adc455255f9">More...</a><br /></td></tr>
<tr class="separator:a963866c44cad49de114b0adc455255f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e94926b62576373d9feeb8a9e4b218"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a43e94926b62576373d9feeb8a9e4b218">alarm</a> (<a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#afb0dd22ca5daee1992a3303facc84efb">callback_type</a> callback, void *md)</td></tr>
<tr class="memdesc:a43e94926b62576373d9feeb8a9e4b218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for common case of configuring with static callback.  <a href="#a43e94926b62576373d9feeb8a9e4b218">More...</a><br /></td></tr>
<tr class="separator:a43e94926b62576373d9feeb8a9e4b218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6e061c59ac255502914cdc1a0bd1c6"><td class="memTemplParams" colspan="2">template&lt;typename DurT , typename DurT::rep  = 0&gt; </td></tr>
<tr class="memitem:a3f6e061c59ac255502914cdc1a0bd1c6"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a3f6e061c59ac255502914cdc1a0bd1c6">alarm</a> (<a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#afb0dd22ca5daee1992a3303facc84efb">callback_type</a> callback, DurT <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a794a1ef6c56a23fd1441718931556761">interval</a>, void *md=0)</td></tr>
<tr class="memdesc:a3f6e061c59ac255502914cdc1a0bd1c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duration-specified alarm constructor.  <a href="#a3f6e061c59ac255502914cdc1a0bd1c6">More...</a><br /></td></tr>
<tr class="separator:a3f6e061c59ac255502914cdc1a0bd1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f2548cb42a12118f19e79cb5608403"><td class="memItemLeft" align="right" valign="top"><a id="a25f2548cb42a12118f19e79cb5608403"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a25f2548cb42a12118f19e79cb5608403">~alarm</a> ()</td></tr>
<tr class="memdesc:a25f2548cb42a12118f19e79cb5608403"><td class="mdescLeft">&#160;</td><td class="mdescRight">On destruction the alarm is cancelled. <br /></td></tr>
<tr class="separator:a25f2548cb42a12118f19e79cb5608403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ddfde8d4319bce648077ca8cee50e53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a0ddfde8d4319bce648077ca8cee50e53">schedule</a> ()</td></tr>
<tr class="memdesc:a0ddfde8d4319bce648077ca8cee50e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue the alarm to execute at its current <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a3c773664aedabf4898a5a48500216010" title="The value of (the low 32 bits of) uptime::now() at which the alarm should fire.">deadline()</a>.  <a href="#a0ddfde8d4319bce648077ca8cee50e53">More...</a><br /></td></tr>
<tr class="separator:a0ddfde8d4319bce648077ca8cee50e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05bcdb580b198a0aadf14db09e625969"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a05bcdb580b198a0aadf14db09e625969">schedule_offset</a> (int offset)</td></tr>
<tr class="memdesc:a05bcdb580b198a0aadf14db09e625969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue the alarm to execute at <code>offset</code> ticks from the current time.  <a href="#a05bcdb580b198a0aadf14db09e625969">More...</a><br /></td></tr>
<tr class="separator:a05bcdb580b198a0aadf14db09e625969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bba03c3be0ee55a0e437bf0c6cd0d4e"><td class="memTemplParams" colspan="2">template&lt;typename DurT &gt; </td></tr>
<tr class="memitem:a4bba03c3be0ee55a0e437bf0c6cd0d4e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a4bba03c3be0ee55a0e437bf0c6cd0d4e">schedule_offset</a> (DurT offset)</td></tr>
<tr class="memdesc:a4bba03c3be0ee55a0e437bf0c6cd0d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule an alarm using a <code>std::chrono</code> duration.  <a href="#a4bba03c3be0ee55a0e437bf0c6cd0d4e">More...</a><br /></td></tr>
<tr class="separator:a4bba03c3be0ee55a0e437bf0c6cd0d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3acf6af09cf8b75632740f6ce50e639"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a89c77d2d2f84abc5e8ab32db6259a187">state_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#af3acf6af09cf8b75632740f6ce50e639">cancel</a> ()</td></tr>
<tr class="memdesc:af3acf6af09cf8b75632740f6ce50e639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel a potentially-scheduled alarm.  <a href="#af3acf6af09cf8b75632740f6ce50e639">More...</a><br /></td></tr>
<tr class="separator:af3acf6af09cf8b75632740f6ce50e639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794a1ef6c56a23fd1441718931556761"><td class="memItemLeft" align="right" valign="top"><a id="a794a1ef6c56a23fd1441718931556761"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a794a1ef6c56a23fd1441718931556761">interval</a> () const</td></tr>
<tr class="memdesc:a794a1ef6c56a23fd1441718931556761"><td class="mdescLeft">&#160;</td><td class="mdescRight">An offset added to <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a3c773664aedabf4898a5a48500216010" title="The value of (the low 32 bits of) uptime::now() at which the alarm should fire.">deadline()</a> prior to invoking the callback when the alarm fires. <br /></td></tr>
<tr class="separator:a794a1ef6c56a23fd1441718931556761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34235d36f91a7352c85128fa6a4f9780"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnrfcxx_1_1clock_1_1alarm.html">alarm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a34235d36f91a7352c85128fa6a4f9780">set_interval</a> (unsigned int <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a794a1ef6c56a23fd1441718931556761">interval</a>)</td></tr>
<tr class="memdesc:a34235d36f91a7352c85128fa6a4f9780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a794a1ef6c56a23fd1441718931556761" title="An offset added to deadline() prior to invoking the callback when the alarm fires.">interval()</a> in uptime ticks.  <a href="#a34235d36f91a7352c85128fa6a4f9780">More...</a><br /></td></tr>
<tr class="separator:a34235d36f91a7352c85128fa6a4f9780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad170b744dfd743820bf15732149c515a"><td class="memTemplParams" colspan="2"><a id="ad170b744dfd743820bf15732149c515a"></a>
template&lt;typename DurT , typename DurT::rep  = 0&gt; </td></tr>
<tr class="memitem:ad170b744dfd743820bf15732149c515a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classnrfcxx_1_1clock_1_1alarm.html">alarm</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#ad170b744dfd743820bf15732149c515a">set_interval</a> (DurT <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a794a1ef6c56a23fd1441718931556761">interval</a>)</td></tr>
<tr class="memdesc:ad170b744dfd743820bf15732149c515a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a794a1ef6c56a23fd1441718931556761" title="An offset added to deadline() prior to invoking the callback when the alarm fires.">interval()</a> using a given duration. <br /></td></tr>
<tr class="separator:ad170b744dfd743820bf15732149c515a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c773664aedabf4898a5a48500216010"><td class="memItemLeft" align="right" valign="top"><a id="a3c773664aedabf4898a5a48500216010"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a3c773664aedabf4898a5a48500216010">deadline</a> () const</td></tr>
<tr class="memdesc:a3c773664aedabf4898a5a48500216010"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of (the low 32 bits of) <a class="el" href="classnrfcxx_1_1clock_1_1uptime.html#a1b07645eb81ce9d3004fcc2b9b038c56" title="Full-range uptime counter.">uptime::now()</a> at which the alarm should fire. <br /></td></tr>
<tr class="separator:a3c773664aedabf4898a5a48500216010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f3644b734cdc9ae8dedf2f58775f07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnrfcxx_1_1clock_1_1alarm.html">alarm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#ac8f3644b734cdc9ae8dedf2f58775f07">set_deadline</a> (unsigned int <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a3c773664aedabf4898a5a48500216010">deadline</a>)</td></tr>
<tr class="memdesc:ac8f3644b734cdc9ae8dedf2f58775f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the deadline for the alarm to fire.  <a href="#ac8f3644b734cdc9ae8dedf2f58775f07">More...</a><br /></td></tr>
<tr class="separator:ac8f3644b734cdc9ae8dedf2f58775f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aec3bb716d1df6de53ba11445c74c60d0"><td class="memTemplParams" colspan="2">template&lt;event_set::event_type EVT, bool reschedule = false&gt; </td></tr>
<tr class="memitem:aec3bb716d1df6de53ba11445c74c60d0"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html">alarm</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#aec3bb716d1df6de53ba11445c74c60d0">for_event</a> (<a class="el" href="classnrfcxx_1_1event__set.html">event_set</a> &amp;events)</td></tr>
<tr class="memdesc:aec3bb716d1df6de53ba11445c74c60d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory producing an alarm with a callback that sets an event.  <a href="#aec3bb716d1df6de53ba11445c74c60d0">More...</a><br /></td></tr>
<tr class="separator:aec3bb716d1df6de53ba11445c74c60d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a386f443007e0245a48d97df39e40d48c"><td class="memItemLeft" align="right" valign="top">void *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a386f443007e0245a48d97df39e40d48c">metadata</a></td></tr>
<tr class="memdesc:a386f443007e0245a48d97df39e40d48c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to arbitrary data associated with the alarm.  <a href="#a386f443007e0245a48d97df39e40d48c">More...</a><br /></td></tr>
<tr class="separator:a386f443007e0245a48d97df39e40d48c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aefa1d80ba3891e842a3245dcfee71c95"><td class="memItemLeft" align="right" valign="top"><a id="aefa1d80ba3891e842a3245dcfee71c95"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#aefa1d80ba3891e842a3245dcfee71c95">ordinal_</a> (unsigned int now) const noexcept</td></tr>
<tr class="memdesc:aefa1d80ba3891e842a3245dcfee71c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate an ordinal for the alarm using the distance from <code>now</code> until its deadline. <br /></td></tr>
<tr class="separator:aefa1d80ba3891e842a3245dcfee71c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a44b71695bd9030463ba7fdfeec698ae0"><td class="memItemLeft" align="right" valign="top"><a id="a44b71695bd9030463ba7fdfeec698ae0"></a>
<a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#afb0dd22ca5daee1992a3303facc84efb">callback_type</a> const&#160;</td><td class="memItemRight" valign="bottom"><b>callback_</b></td></tr>
<tr class="separator:a44b71695bd9030463ba7fdfeec698ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e710f19475dc8ef0aa22dc86f76cb28"><td class="memItemLeft" align="right" valign="top"><a id="a8e710f19475dc8ef0aa22dc86f76cb28"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>deadline_</b> = 0</td></tr>
<tr class="separator:a8e710f19475dc8ef0aa22dc86f76cb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef95919aba6491946962970b6f61245"><td class="memItemLeft" align="right" valign="top"><a id="acef95919aba6491946962970b6f61245"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>interval_</b></td></tr>
<tr class="separator:acef95919aba6491946962970b6f61245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8876592f1a54897d3439ac5371ceda"><td class="memItemLeft" align="right" valign="top"><a id="a5f8876592f1a54897d3439ac5371ceda"></a>
<a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a89c77d2d2f84abc5e8ab32db6259a187">state_type</a> volatile&#160;</td><td class="memItemRight" valign="bottom"><b>state_</b> = <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a89c77d2d2f84abc5e8ab32db6259a187a8d87ec06648b45a8ad33dd20d8a0799c">ST_unscheduled</a></td></tr>
<tr class="separator:a5f8876592f1a54897d3439ac5371ceda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ceec99764c894672ebab8a11b772d6"><td class="memItemLeft" align="right" valign="top"><a id="ab9ceec99764c894672ebab8a11b772d6"></a>
<a class="el" href="classnrfcxx_1_1clock_1_1alarm.html">alarm</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>next_</b> = nullptr</td></tr>
<tr class="separator:ab9ceec99764c894672ebab8a11b772d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:acd9cce0c43172f5c6c3552f7b028a6cd"><td class="memItemLeft" align="right" valign="top"><a id="acd9cce0c43172f5c6c3552f7b028a6cd"></a>
static alarm_queue&#160;</td><td class="memItemRight" valign="bottom"><b>queue_</b></td></tr>
<tr class="separator:acd9cce0c43172f5c6c3552f7b028a6cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class supporting an alarm with custom callback and repeatability. </p>
<p>This capability supports an unbounded number of alarms multiplexed onto a capture/compare register in the <a class="el" href="classnrfcxx_1_1clock_1_1uptime.html" title="Support for a persistent system clock with 32 KiHz resolution.">clock::uptime</a> infrastructure. Alarms are given a <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a3c773664aedabf4898a5a48500216010" title="The value of (the low 32 bits of) uptime::now() at which the alarm should fire.">deadline()</a>, which is <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a05bcdb580b198a0aadf14db09e625969">normally specified</a> relative to the time at which they are scheduled but can be <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a0ddfde8d4319bce648077ca8cee50e53">absolute</a>.</p>
<p>They may have a non-zero <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a794a1ef6c56a23fd1441718931556761" title="An offset added to deadline() prior to invoking the callback when the alarm fires.">interval()</a> which is used to support periodic alarms.</p>
<p>They generally have a <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#afb0dd22ca5daee1992a3303facc84efb">callback</a> which is invoked from the uptime interrupt handler performs alarm-specific actions, as well as controlling whether the alarm is rescheduled.</p>
<dl class="section note"><dt>Note</dt><dd>Several member functions are only safe to use when alarms are unscheduled. Alarms are unscheduled during their callbacks; these functions (including <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a34235d36f91a7352c85128fa6a4f9780" title="Set the interval() in uptime ticks.">set_interval()</a> and <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#ac8f3644b734cdc9ae8dedf2f58775f07" title="Set the deadline for the alarm to fire.">set_deadline()</a>) are safe to use in that context. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="afb0dd22ca5daee1992a3303facc84efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb0dd22ca5daee1992a3303facc84efb">&#9670;&nbsp;</a></span>callback_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#afb0dd22ca5daee1992a3303facc84efb">nrfcxx::clock::alarm::callback_type</a> =  std::function&lt;bool(<a class="el" href="classnrfcxx_1_1clock_1_1alarm.html">alarm</a>&amp; <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html">alarm</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The signature of an alarm callback function. </p>
<p>In addition to performing other operations the callback may change the <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a3c773664aedabf4898a5a48500216010" title="The value of (the low 32 bits of) uptime::now() at which the alarm should fire.">deadline()</a> of the alarm and, through the return value, control whether the alarm is rescheduled. If <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a794a1ef6c56a23fd1441718931556761" title="An offset added to deadline() prior to invoking the callback when the alarm fires.">interval()</a> is not zero the <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a3c773664aedabf4898a5a48500216010" title="The value of (the low 32 bits of) uptime::now() at which the alarm should fire.">deadline()</a> when the callback is invoked is <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a794a1ef6c56a23fd1441718931556761" title="An offset added to deadline() prior to invoking the callback when the alarm fires.">interval()</a> ticks past the deadline that caused the callback to be invoked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alarm</td><td>reference to the alarm associated with the callback. This may be cast to a subclass type to access callback/alarm-specific data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the alarm should be rescheduled, otherwise <code>false</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Callbacks are invoked from the uptime RTC FLIH, so should do their thing and exit as fast as possible. Interrupts are not disabled while alarm callbacks are being processed. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a89c77d2d2f84abc5e8ab32db6259a187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89c77d2d2f84abc5e8ab32db6259a187">&#9670;&nbsp;</a></span>state_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a89c77d2d2f84abc5e8ab32db6259a187">nrfcxx::clock::alarm::state_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constants identifying the alarm state. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a89c77d2d2f84abc5e8ab32db6259a187a8d87ec06648b45a8ad33dd20d8a0799c"></a>ST_unscheduled&#160;</td><td class="fielddoc"><p>Alarm has been constructed but has either not yet been scheduled or has completed. </p>
<p>Transitions to <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a89c77d2d2f84abc5e8ab32db6259a187a1198849a88d6502334d22bb14a7a1808" title="Alarm is in the queue to execute at some point in the future.">ST_scheduled</a> on a <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a0ddfde8d4319bce648077ca8cee50e53" title="Queue the alarm to execute at its current deadline().">schedule()</a> operation. </p>
</td></tr>
<tr><td class="fieldname"><a id="a89c77d2d2f84abc5e8ab32db6259a187a1198849a88d6502334d22bb14a7a1808"></a>ST_scheduled&#160;</td><td class="fielddoc"><p>Alarm is in the queue to execute at some point in the future. </p>
<p>Transitions to <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a89c77d2d2f84abc5e8ab32db6259a187a84a42cd6956c6afa4d66f587fc3e15b1" title="Alarm deadline has been reached and the callback will soon be invoked.">ST_ready</a> (asynchronously) or <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a89c77d2d2f84abc5e8ab32db6259a187aa488090673e99ddc10de42f1f64895cb" title="The alarm has been cancelled.">ST_cancelled</a> (through <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#af3acf6af09cf8b75632740f6ce50e639" title="Cancel a potentially-scheduled alarm.">cancel()</a>). </p>
</td></tr>
<tr><td class="fieldname"><a id="a89c77d2d2f84abc5e8ab32db6259a187a84a42cd6956c6afa4d66f587fc3e15b1"></a>ST_ready&#160;</td><td class="fielddoc"><p>Alarm deadline has been reached and the callback will soon be invoked. </p>
<p>If any alarm is in this state the uptime FLIH is executing.</p>
<p>Transitions to <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a89c77d2d2f84abc5e8ab32db6259a187aa7328d628b729f989325e88fa517166c" title="The callback is being invoked.">ST_in_callback</a> (asynchronously) or <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a89c77d2d2f84abc5e8ab32db6259a187aa488090673e99ddc10de42f1f64895cb" title="The alarm has been cancelled.">ST_cancelled</a> (through <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#af3acf6af09cf8b75632740f6ce50e639" title="Cancel a potentially-scheduled alarm.">cancel()</a>). </p>
</td></tr>
<tr><td class="fieldname"><a id="a89c77d2d2f84abc5e8ab32db6259a187aa7328d628b729f989325e88fa517166c"></a>ST_in_callback&#160;</td><td class="fielddoc"><p>The callback is being invoked. </p>
<p>If any alarm is in this state the uptime FLIH is executing.</p>
<p>Transitions to <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a89c77d2d2f84abc5e8ab32db6259a187a1198849a88d6502334d22bb14a7a1808" title="Alarm is in the queue to execute at some point in the future.">ST_scheduled</a> or <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a89c77d2d2f84abc5e8ab32db6259a187a8d87ec06648b45a8ad33dd20d8a0799c" title="Alarm has been constructed but has either not yet been scheduled or has completed.">ST_unscheduled</a> based on <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#afb0dd22ca5daee1992a3303facc84efb" title="The signature of an alarm callback function.">callback_type</a> return value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a89c77d2d2f84abc5e8ab32db6259a187aa488090673e99ddc10de42f1f64895cb"></a>ST_cancelled&#160;</td><td class="fielddoc"><p>The alarm has been cancelled. </p>
<p>No transitions unless <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a0ddfde8d4319bce648077ca8cee50e53" title="Queue the alarm to execute at its current deadline().">schedule()</a> is re-invoked. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a963866c44cad49de114b0adc455255f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a963866c44cad49de114b0adc455255f9">&#9670;&nbsp;</a></span>alarm() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">nrfcxx::clock::alarm::alarm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#afb0dd22ca5daee1992a3303facc84efb">callback_type</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>interval</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>md</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Standard alarm constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>the function to be invoked when the alarm fires.</td></tr>
    <tr><td class="paramname">interval</td><td>an interval that is added to the previous <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a3c773664aedabf4898a5a48500216010" title="The value of (the low 32 bits of) uptime::now() at which the alarm should fire.">deadline()</a> prior to invoking <code>callback</code>, to simplify rescheduling repeating alarms. The effect of #no_callback is to reschedule the alarm if and only if <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a794a1ef6c56a23fd1441718931556761" title="An offset added to deadline() prior to invoking the callback when the alarm fires.">interval()</a> is not zero.</td></tr>
    <tr><td class="paramname">md</td><td>optional pointer stored as <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a386f443007e0245a48d97df39e40d48c" title="Pointer to arbitrary data associated with the alarm.">metadata</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a43e94926b62576373d9feeb8a9e4b218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43e94926b62576373d9feeb8a9e4b218">&#9670;&nbsp;</a></span>alarm() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">nrfcxx::clock::alarm::alarm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#afb0dd22ca5daee1992a3303facc84efb">callback_type</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>md</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload for common case of configuring with static callback. </p>
<p>The alarm is configured without an initial interval.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>as usual</td></tr>
    <tr><td class="paramname">md</td><td>as usual</td></tr>
  </table>
  </dd>
</dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a3f6e061c59ac255502914cdc1a0bd1c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f6e061c59ac255502914cdc1a0bd1c6">&#9670;&nbsp;</a></span>alarm() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DurT , typename DurT::rep  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr nrfcxx::clock::alarm::alarm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#afb0dd22ca5daee1992a3303facc84efb">callback_type</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DurT&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>md</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Duration-specified alarm constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">as</td><td>with the standard construtor.</td></tr>
    <tr><td class="paramname">interval</td><td>an interval specified as a C++ standard duration.</td></tr>
    <tr><td class="paramname">md</td><td>optional pointer stored as <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a386f443007e0245a48d97df39e40d48c" title="Pointer to arbitrary data associated with the alarm.">metadata</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0f942833f0b77cc3a41a69cc92f6416b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f942833f0b77cc3a41a69cc92f6416b">&#9670;&nbsp;</a></span>active()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nrfcxx::clock::alarm::active </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the alarm state is one of <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a89c77d2d2f84abc5e8ab32db6259a187a1198849a88d6502334d22bb14a7a1808" title="Alarm is in the queue to execute at some point in the future.">ST_scheduled</a>, <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a89c77d2d2f84abc5e8ab32db6259a187a84a42cd6956c6afa4d66f587fc3e15b1" title="Alarm deadline has been reached and the callback will soon be invoked.">ST_ready</a>, or <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a89c77d2d2f84abc5e8ab32db6259a187aa7328d628b729f989325e88fa517166c" title="The callback is being invoked.">ST_in_callback</a>. </p>
<p>If <code>false</code> the alarm must be scheduled. </p>

</div>
</div>
<a id="af3acf6af09cf8b75632740f6ce50e639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3acf6af09cf8b75632740f6ce50e639">&#9670;&nbsp;</a></span>cancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a89c77d2d2f84abc5e8ab32db6259a187">state_type</a> nrfcxx::clock::alarm::cancel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel a potentially-scheduled alarm. </p>
<p>If the alarm is found in the scheduled or ready queue its <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a9f98b48056733c3b1da5ed109fc8ba32" title="The current state of the alarm.">state()</a> will be updated to <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a89c77d2d2f84abc5e8ab32db6259a187aa488090673e99ddc10de42f1f64895cb" title="The alarm has been cancelled.">ST_cancelled</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a9f98b48056733c3b1da5ed109fc8ba32" title="The current state of the alarm.">state()</a> of the alarm prior to its being cancelled.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>You may cancel an alarm in any state or context, but if the returned state is <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a89c77d2d2f84abc5e8ab32db6259a187aa7328d628b729f989325e88fa517166c" title="The callback is being invoked.">ST_in_callback</a> the cancellation will be superseded by the <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#afb0dd22ca5daee1992a3303facc84efb">callback</a> return value. The application should either re-issue the cancel or somehow communicate its desires to the callback so it does not request that the alarm be rescheduled. </dd></dl>

</div>
</div>
<a id="aec3bb716d1df6de53ba11445c74c60d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec3bb716d1df6de53ba11445c74c60d0">&#9670;&nbsp;</a></span>for_event()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;event_set::event_type EVT, bool reschedule = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html">alarm</a> nrfcxx::clock::alarm::for_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnrfcxx_1_1event__set.html">event_set</a> &amp;&#160;</td>
          <td class="paramname"><em>events</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory producing an alarm with a callback that sets an event. </p>
<p>This is a fairly common need. While you can do this with: </p><pre class="fragment">alarm clock::alarm{[&amp;events](auto&amp;) {
  events.set(EVT);
  return true;
}};
</pre><p>that's pretty verbose. Attempts to push the lambda construction down into a constructor end up pulling in malloc because the resulting object requires external storage either for the values it captures (reference to events, value of event, return value) or because it has to make copy of the function object rather than construct it in place (even if the constant values are captured in template constructor parameters).</p>
<p>The following has the same efficiency and is a little cleaner:</p>
<p>auto alarm = alarm::for_event&lt;EVT, true&gt;(events);</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">EVT</td><td>the event that is to be set.</td></tr>
    <tr><td class="paramname">reschedule</td><td>the value to be returned from the synthesized alarm callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">events</td><td>reference to the event set to which EVT will be added when the alarm fires.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new alarm instance with the required callback </dd></dl>

</div>
</div>
<a id="a0ddfde8d4319bce648077ca8cee50e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ddfde8d4319bce648077ca8cee50e53">&#9670;&nbsp;</a></span>schedule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrfcxx::clock::alarm::schedule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queue the alarm to execute at its current <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a3c773664aedabf4898a5a48500216010" title="The value of (the low 32 bits of) uptime::now() at which the alarm should fire.">deadline()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This operational is behaviorally identical to invoking <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a05bcdb580b198a0aadf14db09e625969" title="Queue the alarm to execute at offset ticks from the current time.">schedule_offset()</a> with the signed parameter that would produce <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a3c773664aedabf4898a5a48500216010" title="The value of (the low 32 bits of) uptime::now() at which the alarm should fire.">deadline()</a>. Consequently if the signed difference between current time and deadline appears negative, the alarm may fire "immediately".</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Invoking this function when the alarm is in states <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a89c77d2d2f84abc5e8ab32db6259a187a1198849a88d6502334d22bb14a7a1808" title="Alarm is in the queue to execute at some point in the future.">ST_scheduled</a>, <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a89c77d2d2f84abc5e8ab32db6259a187a84a42cd6956c6afa4d66f587fc3e15b1" title="Alarm deadline has been reached and the callback will soon be invoked.">ST_ready</a>, or <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a89c77d2d2f84abc5e8ab32db6259a187aa7328d628b729f989325e88fa517166c" title="The callback is being invoked.">ST_in_callback</a> will result in undefined behavior. </dd></dl>

</div>
</div>
<a id="a4bba03c3be0ee55a0e437bf0c6cd0d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bba03c3be0ee55a0e437bf0c6cd0d4e">&#9670;&nbsp;</a></span>schedule_offset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DurT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nrfcxx::clock::alarm::schedule_offset </td>
          <td>(</td>
          <td class="paramtype">DurT&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Schedule an alarm using a <code>std::chrono</code> duration. </p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a05bcdb580b198a0aadf14db09e625969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05bcdb580b198a0aadf14db09e625969">&#9670;&nbsp;</a></span>schedule_offset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrfcxx::clock::alarm::schedule_offset </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queue the alarm to execute at <code>offset</code> ticks from the current time. </p>
<p>This atomically sets the deadline to the current time plus <code>offset</code> and invokes <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a0ddfde8d4319bce648077ca8cee50e53" title="Queue the alarm to execute at its current deadline().">schedule()</a>. If the offset is negative the deadline will appear to be in the past and the alarm will fire immediately (possibly before this function returns, if interrupts are enabled).</p>
<dl class="section note"><dt>Note</dt><dd>Alarms with a signed offset from current time that is less than two ticks may be delayed up to two ticks to ensure reliable timer configuration. This delay is not reflected in the alarm <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a3c773664aedabf4898a5a48500216010" title="The value of (the low 32 bits of) uptime::now() at which the alarm should fire.">deadline()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>the time until the alarm should go off.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is subject to the <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a9f98b48056733c3b1da5ed109fc8ba32" title="The current state of the alarm.">state()</a> constraints of <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a0ddfde8d4319bce648077ca8cee50e53" title="Queue the alarm to execute at its current deadline().">schedule()</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a0ddfde8d4319bce648077ca8cee50e53" title="Queue the alarm to execute at its current deadline().">schedule()</a> </dd></dl>

</div>
</div>
<a id="ac8f3644b734cdc9ae8dedf2f58775f07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f3644b734cdc9ae8dedf2f58775f07">&#9670;&nbsp;</a></span>set_deadline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnrfcxx_1_1clock_1_1alarm.html">alarm</a>&amp; nrfcxx::clock::alarm::set_deadline </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>deadline</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the deadline for the alarm to fire. </p>
<p>This function is generally invoked only from within a <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#afb0dd22ca5daee1992a3303facc84efb" title="The signature of an alarm callback function.">callback_type</a>, to change the deadline of an alarm that will be rescheduled.</p>
<p>It may also be used to set the deadline of an unscheduled alarm prior to invoking <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a0ddfde8d4319bce648077ca8cee50e53" title="Queue the alarm to execute at its current deadline().">schedule()</a>, as in the case where alarms do not automatically reschedule and the desired interval must be offset from the last deadline rather than the current time as with <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a05bcdb580b198a0aadf14db09e625969" title="Queue the alarm to execute at offset ticks from the current time.">schedule_offset()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deadline</td><td>the counter value at which the alarm will fire, nominally when the low 32 bits of <a class="el" href="classnrfcxx_1_1clock_1_1uptime.html#a1b07645eb81ce9d3004fcc2b9b038c56" title="Full-range uptime counter.">uptime::now()</a> increment to <code>deadline</code>. Although this is an absolute value, the difference from the current time will be interpreted as signed value when <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a0ddfde8d4319bce648077ca8cee50e53" title="Queue the alarm to execute at its current deadline().">schedule()</a> is invoked (explicitly or implicitly).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Invoking this function when the alarm is in states <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a89c77d2d2f84abc5e8ab32db6259a187a1198849a88d6502334d22bb14a7a1808" title="Alarm is in the queue to execute at some point in the future.">ST_scheduled</a> or <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a89c77d2d2f84abc5e8ab32db6259a187a84a42cd6956c6afa4d66f587fc3e15b1" title="Alarm deadline has been reached and the callback will soon be invoked.">ST_ready</a> will result in undefined behavior. </dd></dl>

</div>
</div>
<a id="a34235d36f91a7352c85128fa6a4f9780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34235d36f91a7352c85128fa6a4f9780">&#9670;&nbsp;</a></span>set_interval()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnrfcxx_1_1clock_1_1alarm.html">alarm</a>&amp; nrfcxx::clock::alarm::set_interval </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a794a1ef6c56a23fd1441718931556761" title="An offset added to deadline() prior to invoking the callback when the alarm fires.">interval()</a> in uptime ticks. </p>
<dl class="section warning"><dt>Warning</dt><dd>Invoking this function when the alarm is in states <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a89c77d2d2f84abc5e8ab32db6259a187a1198849a88d6502334d22bb14a7a1808" title="Alarm is in the queue to execute at some point in the future.">ST_scheduled</a> or <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#a89c77d2d2f84abc5e8ab32db6259a187a84a42cd6956c6afa4d66f587fc3e15b1" title="Alarm deadline has been reached and the callback will soon be invoked.">ST_ready</a> will result in undefined behavior. </dd></dl>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a386f443007e0245a48d97df39e40d48c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a386f443007e0245a48d97df39e40d48c">&#9670;&nbsp;</a></span>metadata</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* const nrfcxx::clock::alarm::metadata</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to arbitrary data associated with the alarm. </p>
<p>This exists because in modern C++ you can't generally pull the trick of using <code>offsetof(struct, field)</code> to derive a pointer to a structure from a pointer to a member of that structure. Such a cast is only allowed when the structure is a POD or has standard layout, which excludes anything that has non-static data members that are references. As <a class="el" href="classnrfcxx_1_1clock_1_1alarm.html#afb0dd22ca5daee1992a3303facc84efb">callbacks</a> are passed pointers to alarms, and the operation of the callback may require access to sibling members, casting this pointer instead provides a solution: </p><pre class="fragment">bool my_callback (clock::alarm&amp; alarm)
{
   auto self = static_cast&lt;my_container*&gt;(alarm.metadata);
   self-&gt;events.set(self.event);
   return false;
}
</pre> 
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>nrfcxx/<a class="el" href="clock_8hpp_source.html">clock.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
